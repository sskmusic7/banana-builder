<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üçå Batch Prompt Generator - AI Image Generator</title>
    <!-- Libraries for PDF and ZIP export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Library for image metadata (EXIF) -->
    <script src="https://cdn.jsdelivr.net/npm/piexifjs@2.0.0/piexif.js"></script>
    <style>
        :root {
            --primary: #667eea;
            --primary-dark: #5568d3;
            --secondary: #764ba2;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --info: #17a2b8;
            --bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --shadow: 0 20px 60px rgba(0,0,0,0.3);
            --shadow-hover: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: var(--bg-gradient);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: var(--shadow);
            padding: 40px;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .home-btn {
            display: inline-block;
            margin-bottom: 20px;
            padding: 8px 16px;
            background: var(--primary);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: transform 0.2s ease;
        }

        .home-btn:hover {
            transform: translateY(-2px);
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 700;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            border: 1px solid #e9ecef;
        }

        .section-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary);
        }

        input[type="text"],
        input[type="password"],
        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary);
        }

        .btn {
            background: var(--bg-gradient);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            display: inline-block;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-hover);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-danger {
            background: var(--danger);
        }

        .btn-success {
            background: var(--success);
        }

        .prompt-list {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .prompt-item {
            padding: 10px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid var(--primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .prompt-item-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .delete-prompt-btn {
            background: var(--danger);
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s ease;
        }

        .delete-prompt-btn:hover {
            background: #c82333;
        }

        .prompt-item.processing {
            border-left-color: var(--info);
            background: #e7f3ff;
        }

        .prompt-item.success {
            border-left-color: var(--success);
            background: #d4edda;
        }

        .prompt-item.error {
            border-left-color: var(--danger);
            background: #f8d7da;
        }

        .prompt-text {
            flex: 1;
            font-size: 13px;
            color: #333;
            word-break: break-word;
            margin-right: 10px;
        }

        .prompt-status {
            font-size: 12px;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .status-pending {
            color: #666;
        }

        .status-processing {
            color: var(--info);
            background: #d1ecf1;
        }

        .status-success {
            color: var(--success);
            background: #d4edda;
        }

        .status-error {
            color: var(--danger);
            background: #f8d7da;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .result-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .result-card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-hover);
        }

        .result-image {
            width: 100%;
            height: 300px;
            object-fit: cover;
            background: #f8f9fa;
        }

        .result-info {
            padding: 15px;
        }

        .result-prompt {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
            word-break: break-word;
            line-height: 1.6;
        }

        .result-prompt.collapsed {
            max-height: 120px;
            overflow: hidden;
            position: relative;
        }

        .result-prompt.collapsed::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(to bottom, transparent, white);
        }

        .expand-prompt-btn {
            background: transparent;
            border: none;
            color: var(--primary);
            font-size: 11px;
            cursor: pointer;
            padding: 4px 0;
            margin-top: 5px;
            text-decoration: underline;
            font-weight: 600;
        }

        .expand-prompt-btn:hover {
            color: var(--primary-dark);
        }

        .history-section {
            margin-top: 40px;
            padding-top: 40px;
            border-top: 2px solid #e9ecef;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .history-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .history-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .history-item {
            background: white;
            border: 2px solid #ddd;
            border-radius: 12px;
            padding: 10px;
            position: relative;
            transition: all 0.3s;
        }

        .history-item:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .history-item.selected {
            border-color: var(--primary);
            background: #f0f0ff;
        }

        .history-item-checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            cursor: pointer;
            z-index: 10;
        }

        .history-item img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .history-item-prompt {
            font-size: 0.85em;
            color: #666;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        .history-item-date {
            font-size: 0.75em;
            color: #999;
            margin-top: 5px;
        }

        .select-all-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .result-actions {
            display: flex;
            gap: 8px;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--bg-gradient);
            transition: width 0.3s ease;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: #f8f9fa;
            padding: 15px 20px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary);
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .dimension-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .file-upload-area {
            border: 3px dashed #ddd;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .file-upload-area:hover {
            border-color: var(--primary);
            background: #f8f9ff;
        }

        .file-upload-area.dragover {
            border-color: var(--primary);
            background: #e7f3ff;
        }

        .file-upload-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .file-upload-area input[type="file"] {
            display: none;
        }

        .image-previews {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .image-preview-item {
            position: relative;
            background: #f8f9fa;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #e9ecef;
        }

        .image-preview-item img {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }

        .image-preview-item .remove-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .image-preview-item .image-info {
            padding: 8px;
            font-size: 11px;
            color: #666;
            word-break: break-word;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            .dimension-group {
                grid-template-columns: 1fr;
            }

            .results-grid {
                grid-template-columns: 1fr;
            }

            .image-previews {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="/" class="home-btn">‚Üê Home</a>
        
        <header>
            <h1>üçå Batch Prompt Generator</h1>
            <p class="subtitle">Generate multiple images from prompts automatically</p>
        </header>

        <div class="section">
            <div class="section-title">‚öôÔ∏è Settings</div>
            
            <div class="form-group">
                <label>Gemini API Key *</label>
                <input type="password" id="apiKey" placeholder="Enter your Gemini API key" />
            </div>

            <div class="form-group">
                <label>Model</label>
                <select id="modelSelect">
                    <option value="gemini-2.5-flash-image">Gemini 2.5 Flash Image</option>
                    <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                    <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                    <option value="seedream-4">Seedream 4 (Freepik)</option>
                </select>
            </div>

            <div class="form-group" id="seedreamApiKeyGroup" style="display: none;">
                <label>Freepik API Key *</label>
                <input type="password" id="seedreamApiKey" placeholder="Enter your Freepik API key" />
                <p style="font-size: 12px; color: #666; margin-top: 5px;">Get your API key from <a href="https://developers.freepik.com/" target="_blank">Freepik Developers</a></p>
            </div>

            <div class="form-group dimension-group">
                <div>
                    <label>Width</label>
                    <input type="number" id="width" value="1024" min="256" max="2048" step="64" />
                </div>
                <div>
                    <label>Height</label>
                    <input type="number" id="height" value="1024" min="256" max="2048" step="64" />
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">üì∑ Reference Images (Optional)</div>
            <div class="form-group">
                <label>Upload 1-3 images to guide generation (e.g., person, style reference)</label>
                <div class="file-upload-area" id="fileUploadArea">
                    <div class="file-upload-icon">üì§</div>
                    <p><strong>Click to upload</strong> or drag and drop</p>
                    <p style="color: #666; font-size: 0.9em; margin-top: 5px;">JPG, PNG, WebP (Max 10MB each, up to 3 images)</p>
                    <input type="file" id="imageInput" accept="image/*" multiple />
                </div>
                <div class="image-previews" id="imagePreviews"></div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">üìù Prompts</div>
            
            <div class="form-group">
                <label>Enter prompts (numbered items, double newlines, or one per line)</label>
                <textarea id="promptsInput" rows="10" placeholder="Paste your prompts here. Supports:&#10;&#10;1. Numbered prompts (1., 2., 3., etc.)&#10;2. Double newlines between prompts&#10;3. One prompt per line&#10;&#10;Commas within prompts are preserved."></textarea>
            </div>

            <div class="form-group">
                <label>Extra Prompt Guidance (Optional)</label>
                <textarea id="extraPromptGuidance" rows="3" placeholder="Add extra instructions that will be appended to all prompts (e.g., 'all images in NYC', 'use golden hour lighting', etc.)"></textarea>
                <p style="font-size: 12px; color: #666; margin-top: 5px;">This text will be automatically appended to the end of each generated prompt.</p>
            </div>

            <div id="promptList" class="prompt-list" style="display: none;"></div>

            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="btn" id="parseBtn">Parse Prompts</button>
                <button class="btn btn-secondary" id="clearBtn">Clear</button>
            </div>
        </div>

        <div id="progressSection" style="display: none;">
            <div class="section">
                <div class="section-title">üìä Progress</div>
                
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Total</div>
                        <div class="stat-value" id="totalCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Completed</div>
                        <div class="stat-value" id="completedCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Failed</div>
                        <div class="stat-value" id="failedCount">0</div>
                    </div>
                </div>

                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>

                <div style="margin-top: 15px;">
                    <button class="btn btn-danger" id="stopBtn">Stop Generation</button>
                </div>
            </div>
        </div>

        <div id="resultsSection" style="display: none;">
            <div class="section">
                <div class="section-title">üé® Generated Images</div>
                
                <div style="margin-bottom: 15px;">
                    <button class="btn btn-success" id="downloadAllBtn">Download All Images</button>
                </div>

                <div class="results-grid" id="resultsGrid"></div>
            </div>
        </div>

        <!-- History Section -->
        <div class="history-section section" id="historySection">
            <div class="history-header">
                <h2 style="margin: 0; font-size: 1.5em;">üìö Generation History</h2>
                <div class="history-controls">
                    <div class="select-all-controls">
                        <button class="btn" id="selectAllBtn" style="background: #6c757d; color: white;">Select All</button>
                        <button class="btn" id="deselectAllBtn" style="background: #6c757d; color: white;">Deselect All</button>
                    </div>
                    <button class="btn btn-success" id="exportPdfBtn">üìÑ Export PDF</button>
                    <button class="btn btn-primary" id="exportZipBtn">üì¶ Export ZIP</button>
                    <button class="btn btn-danger" id="clearHistoryBtn">üóëÔ∏è Clear History</button>
                </div>
            </div>
            <div class="history-grid" id="historyGrid">
                <!-- History items will be added here dynamically -->
            </div>
            <p id="noHistoryMessage" style="text-align: center; color: #999; padding: 20px; display: none;">
                No generation history yet. Generate some images to see them here!
            </p>
        </div>
    </div>

    <script>
        const state = {
            prompts: [],
            results: [],
            isProcessing: false,
            shouldStop: false,
            currentIndex: 0,
            uploadedImages: [], // Array of {base64, mimeType, name, preview}
            history: [] // Array of {id, imageBase64, prompt, timestamp, selected}
        };

        const elements = {
            apiKey: document.getElementById('apiKey'),
            modelSelect: document.getElementById('modelSelect'),
            seedreamApiKey: document.getElementById('seedreamApiKey'),
            seedreamApiKeyGroup: document.getElementById('seedreamApiKeyGroup'),
            width: document.getElementById('width'),
            height: document.getElementById('height'),
            promptsInput: document.getElementById('promptsInput'),
            extraPromptGuidance: document.getElementById('extraPromptGuidance'),
            promptList: document.getElementById('promptList'),
            parseBtn: document.getElementById('parseBtn'),
            clearBtn: document.getElementById('clearBtn'),
            progressSection: document.getElementById('progressSection'),
            resultsSection: document.getElementById('resultsSection'),
            totalCount: document.getElementById('totalCount'),
            completedCount: document.getElementById('completedCount'),
            failedCount: document.getElementById('failedCount'),
            progressFill: document.getElementById('progressFill'),
            stopBtn: document.getElementById('stopBtn'),
            downloadAllBtn: document.getElementById('downloadAllBtn'),
            resultsGrid: document.getElementById('resultsGrid'),
            fileUploadArea: document.getElementById('fileUploadArea'),
            imageInput: document.getElementById('imageInput'),
            imagePreviews: document.getElementById('imagePreviews'),
            historySection: document.getElementById('historySection'),
            historyGrid: document.getElementById('historyGrid'),
            noHistoryMessage: document.getElementById('noHistoryMessage'),
            selectAllBtn: document.getElementById('selectAllBtn'),
            deselectAllBtn: document.getElementById('deselectAllBtn'),
            exportPdfBtn: document.getElementById('exportPdfBtn'),
            exportZipBtn: document.getElementById('exportZipBtn'),
            clearHistoryBtn: document.getElementById('clearHistoryBtn')
        };

        // Load saved API keys and settings
        const savedKey = localStorage.getItem('batch-generator-api-key');
        if (savedKey) {
            elements.apiKey.value = savedKey;
        }
        const savedSeedreamKey = localStorage.getItem('batch-generator-seedream-api-key');
        if (savedSeedreamKey) {
            elements.seedreamApiKey.value = savedSeedreamKey;
        }
        const savedExtraGuidance = localStorage.getItem('batch-generator-extra-guidance');
        if (savedExtraGuidance) {
            elements.extraPromptGuidance.value = savedExtraGuidance;
        }

        // Save API keys and settings on change
        elements.apiKey.addEventListener('input', () => {
            localStorage.setItem('batch-generator-api-key', elements.apiKey.value);
        });
        elements.seedreamApiKey.addEventListener('input', () => {
            localStorage.setItem('batch-generator-seedream-api-key', elements.seedreamApiKey.value);
        });
        elements.extraPromptGuidance.addEventListener('input', () => {
            localStorage.setItem('batch-generator-extra-guidance', elements.extraPromptGuidance.value);
        });

        // Show/hide Seedream API key field based on model selection
        elements.modelSelect.addEventListener('change', () => {
            if (elements.modelSelect.value === 'seedream-4') {
                elements.seedreamApiKeyGroup.style.display = 'block';
                elements.apiKey.closest('.form-group').style.display = 'none';
            } else {
                elements.seedreamApiKeyGroup.style.display = 'none';
                elements.apiKey.closest('.form-group').style.display = 'block';
            }
        });

        // Initialize on load
        if (elements.modelSelect.value === 'seedream-4') {
            elements.seedreamApiKeyGroup.style.display = 'block';
            elements.apiKey.closest('.form-group').style.display = 'none';
        }

        // Image upload handlers
        elements.fileUploadArea.addEventListener('click', () => {
            elements.imageInput.click();
        });

        elements.fileUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.fileUploadArea.classList.add('dragover');
        });

        elements.fileUploadArea.addEventListener('dragleave', () => {
            elements.fileUploadArea.classList.remove('dragover');
        });

        elements.fileUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.fileUploadArea.classList.remove('dragover');
            
            const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
            if (files.length > 0) {
                handleImageUploads(files);
            }
        });

        elements.imageInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/'));
            if (files.length > 0) {
                handleImageUploads(files);
            }
        });

        function handleImageUploads(files) {
            // Limit to 3 images total
            const remainingSlots = 3 - state.uploadedImages.length;
            const filesToProcess = files.slice(0, remainingSlots);

            if (files.length > remainingSlots) {
                alert(`You can only upload up to 3 images. Processing first ${remainingSlots} file(s).`);
            }

            filesToProcess.forEach(file => {
                if (file.size > 10 * 1024 * 1024) {
                    alert(`File ${file.name} is too large (max 10MB). Skipping.`);
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    const matches = dataUrl.match(/^data:(.+);base64,(.+)$/);
                    if (matches) {
                        state.uploadedImages.push({
                            base64: matches[2],
                            mimeType: matches[1],
                            name: file.name,
                            preview: dataUrl
                        });
                        renderImagePreviews();
                    }
                };
                reader.readAsDataURL(file);
            });
        }

        function removeImage(index) {
            state.uploadedImages.splice(index, 1);
            renderImagePreviews();
        }

        function renderImagePreviews() {
            if (state.uploadedImages.length === 0) {
                elements.imagePreviews.innerHTML = '';
                return;
            }

            elements.imagePreviews.innerHTML = state.uploadedImages.map((img, index) => `
                <div class="image-preview-item">
                    <button class="remove-btn" onclick="removeImage(${index})" title="Remove image">√ó</button>
                    <img src="${img.preview}" alt="Preview" />
                    <div class="image-info">${escapeHtml(img.name)}</div>
                </div>
            `).join('');
        }

        // Make removeImage available globally
        window.removeImage = removeImage;

        elements.parseBtn.addEventListener('click', () => {
            let text = elements.promptsInput.value.trim();
            if (!text) {
                alert('Please enter some prompts');
                return;
            }

            // Smart parsing: Handle numbered prompts, double newlines, or single newlines
            let prompts = [];
            
            // First, remove "--- PROMPT X: filename ---" header lines
            text = text.replace(/^---\s*PROMPT\s+\d+:\s*[^\n]+?\s*---\s*/gmi, '');
            
            // Method 1: Check for numbered prompts (1., 2., 3., etc.)
            // Use a regex to match numbered sections: number + title + content (until next number or end)
            const numberedMatches = text.match(/\d+\.\s+[^\n]*(?:\n(?!\d+\.\s)[^\n]*)*/g);
            if (numberedMatches && numberedMatches.length > 0) {
                // Extract content from each numbered section
                prompts = numberedMatches.map(match => {
                    // Remove the number prefix, keep title and content, replace newlines with spaces
                    const fullPrompt = match
                        .replace(/^\d+\.\s+/, '') // Remove "1. " prefix
                        .replace(/\n+/g, ' ')     // Replace newlines with spaces
                        .replace(/\s+/g, ' ')      // Normalize multiple spaces
                        .trim();
                    return fullPrompt;
                }).filter(p => {
                    // Filter out empty prompts and lines that are ONLY "---" separators
                    return p.length > 0 && !p.match(/^---\s*$/);
                });
            } else {
                // Method 2: Split by double newlines (paragraph breaks)
                if (text.includes('\n\n')) {
                    prompts = text
                        .split(/\n\n+/)
                        .map(p => p.trim().replace(/\n/g, ' ')) // Replace single newlines with spaces
                        .filter(p => {
                            // Filter out empty prompts and lines that are ONLY "---" separators
                            return p.length > 0 && !p.match(/^---\s*$/);
                        });
                } else {
                    // Method 3: Split by single newlines (one per line)
                    prompts = text
                        .split(/\n+/)
                        .map(p => p.trim())
                        .filter(p => {
                            // Filter out empty prompts and lines that are ONLY "---" separators
                            return p.length > 0 && !p.match(/^---\s*$/);
                        });
                }
            }

            if (prompts.length === 0) {
                alert('No valid prompts found');
                return;
            }

            state.prompts = prompts.map((prompt, index) => ({
                id: index,
                text: prompt,
                status: 'pending',
                result: null,
                error: null
            }));

            renderPromptList();
            elements.promptList.style.display = 'block';
        });

        elements.clearBtn.addEventListener('click', () => {
            elements.promptsInput.value = '';
            state.prompts = [];
            state.results = [];
            state.uploadedImages = [];
            elements.promptList.style.display = 'none';
            elements.progressSection.style.display = 'none';
            elements.resultsSection.style.display = 'none';
            renderPromptList();
            renderImagePreviews();
            // Note: We don't clear extraPromptGuidance on clear, as it's a master setting
        });

        elements.stopBtn.addEventListener('click', () => {
            state.shouldStop = true;
            state.isProcessing = false;
            elements.stopBtn.disabled = true;
        });

        elements.downloadAllBtn.addEventListener('click', async () => {
            const successfulResults = state.results.filter(r => r.imageUrl);
            if (successfulResults.length === 0) {
                alert('No images to download');
                return;
            }

            // Download with delay between each to avoid browser blocking
            for (let i = 0; i < successfulResults.length; i++) {
                const result = successfulResults[i];
                const index = state.results.indexOf(result);
                
                try {
                    // Fetch the image blob
                    const response = await fetch(result.imageUrl);
                    const blob = await response.blob();
                    
                    let finalBlob = blob;
                    const prompt = result.prompt || '';
                    
                    // Determine image type and add appropriate metadata
                    if (blob.type === 'image/png' || result.imageUrl.includes('.png')) {
                        finalBlob = await addPNGMetadata(blob, prompt);
                    } else if (blob.type === 'image/jpeg' || blob.type === 'image/jpg' || result.imageUrl.includes('.jpg') || result.imageUrl.includes('.jpeg')) {
                        finalBlob = await addJPEGMetadata(blob, prompt);
                    } else {
                        // Try PNG metadata for unknown types
                        finalBlob = await addPNGMetadata(blob, prompt);
                    }
                    
                    // Create download link
                    const url = URL.createObjectURL(finalBlob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `batch-image-${i + 1}.${blob.type.includes('jpeg') ? 'jpg' : 'png'}`;
                    link.click();
                    
                    // Clean up
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                    
                    // Delay between downloads to avoid browser blocking
                    if (i < successfulResults.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                } catch (error) {
                    console.error(`Error downloading image ${i + 1}:`, error);
                    // Fallback to simple download
                    const link = document.createElement('a');
                    link.href = result.imageUrl;
                    link.download = `batch-image-${i + 1}.png`;
                    link.click();
                }
            }
        });

        function renderPromptList() {
            elements.promptList.innerHTML = state.prompts.map((prompt, index) => {
                const statusClass = `status-${prompt.status}`;
                const canDelete = prompt.status === 'pending' && !state.isProcessing;
                return `
                    <div class="prompt-item ${prompt.status}">
                        <div class="prompt-text">${escapeHtml(prompt.text)}</div>
                        <div class="prompt-item-actions">
                            <div class="prompt-status ${statusClass}">
                                ${prompt.status === 'pending' ? '‚è≥ Pending' : 
                                  prompt.status === 'processing' ? '<span class="loading"></span> Processing' :
                                  prompt.status === 'success' ? '‚úì Success' :
                                  prompt.status === 'error' ? '‚úó Error' : ''}
                            </div>
                            ${canDelete ? `<button class="delete-prompt-btn" onclick="deletePrompt(${index})" title="Delete prompt">√ó</button>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            if (state.prompts.length > 0) {
                elements.progressSection.style.display = 'block';
                updateProgress();
            }
        }

        function deletePrompt(index) {
            if (state.isProcessing) {
                alert('Cannot delete prompts while generation is in progress');
                return;
            }
            state.prompts.splice(index, 1);
            // Re-index prompts
            state.prompts = state.prompts.map((p, i) => ({ ...p, id: i }));
            renderPromptList();
        }

        // Make deletePrompt available globally
        window.deletePrompt = deletePrompt;

        function updateProgress() {
            const total = state.prompts.length;
            const completed = state.results.filter(r => r.success).length;
            const failed = state.results.filter(r => !r.success).length;

            elements.totalCount.textContent = total;
            elements.completedCount.textContent = completed;
            elements.failedCount.textContent = failed;

            const progress = total > 0 ? ((completed + failed) / total) * 100 : 0;
            elements.progressFill.style.width = `${progress}%`;
        }

        async function startGeneration() {
            const selectedModel = elements.modelSelect.value;
            
            if (selectedModel === 'seedream-4') {
                if (!elements.seedreamApiKey.value.trim()) {
                    alert('Please enter your Freepik API key');
                    return;
                }
            } else {
                if (!elements.apiKey.value.trim()) {
                    alert('Please enter your Gemini API key');
                    return;
                }
            }

            if (state.prompts.length === 0) {
                alert('Please parse prompts first');
                return;
            }

            state.isProcessing = true;
            state.shouldStop = false;
            state.currentIndex = 0;
            state.results = [];
            elements.stopBtn.disabled = false;
            elements.resultsSection.style.display = 'block';
            elements.resultsGrid.innerHTML = '';

            for (let i = 0; i < state.prompts.length; i++) {
                if (state.shouldStop) {
                    break;
                }

                state.currentIndex = i;
                const prompt = state.prompts[i];
                prompt.status = 'processing';
                renderPromptList();

                try {
                    const apiKey = elements.modelSelect.value === 'seedream-4' 
                        ? elements.seedreamApiKey.value 
                        : elements.apiKey.value;
                    
                    // Append extra prompt guidance if provided
                    let finalPrompt = prompt.text;
                    const extraGuidance = elements.extraPromptGuidance.value.trim();
                    if (extraGuidance) {
                        finalPrompt = `${finalPrompt} ${extraGuidance}`;
                    }
                    
                    const imageUrl = await generateImage(
                        apiKey,
                        finalPrompt,
                        parseInt(elements.width.value),
                        parseInt(elements.height.value),
                        state.uploadedImages
                    );

                    prompt.status = 'success';
                    prompt.result = imageUrl;

                    state.results.push({
                        prompt: finalPrompt, // Store the full prompt with extra guidance
                        originalPrompt: prompt.text, // Store original for reference
                        imageUrl: imageUrl,
                        success: true
                    });

                    renderResult(finalPrompt, imageUrl, state.results.length - 1);
                    
                    // Add to history
                    await addToHistory(imageUrl, finalPrompt, {
                        width: parseInt(elements.width.value),
                        height: parseInt(elements.height.value)
                    });
                } catch (error) {
                    prompt.status = 'error';
                    prompt.error = error.message;

                    // Append extra prompt guidance to error display too
                    let errorPrompt = prompt.text;
                    const extraGuidance = elements.extraPromptGuidance.value.trim();
                    if (extraGuidance) {
                        errorPrompt = `${errorPrompt} ${extraGuidance}`;
                    }
                    
                    state.results.push({
                        prompt: errorPrompt,
                        error: error.message,
                        success: false
                    });

                    renderError(errorPrompt, error.message, state.results.length - 1);
                }

                renderPromptList();
                updateProgress();

                // Small delay between requests to avoid rate limiting
                if (i < state.prompts.length - 1 && !state.shouldStop) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }

            state.isProcessing = false;
            elements.stopBtn.disabled = true;
        }

        async function generateImage(apiKey, prompt, width, height, uploadedImages = []) {
            const model = elements.modelSelect.value;
            
            // Handle Seedream 4 API (async task-based)
            if (model === 'seedream-4') {
                return await generateSeedreamImage(apiKey, prompt, width, height, uploadedImages);
            }
            
            // Handle Gemini API (synchronous)
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;

            // Build the prompt text
            let promptText = prompt;
            
            // If reference images are provided, add instructions to use them for likeness only
            if (uploadedImages && uploadedImages.length > 0) {
                const imageInstruction = `\n\nIMPORTANT: The uploaded reference image(s) are provided for subject likeness, appearance, facial features, and styling reference ONLY. DO NOT copy the pose, position, body arrangement, camera angle, or action from the reference images. Instead, follow the pose, position, action, and composition described in the prompt text above. Use the reference images solely to maintain consistent subject appearance and features across different poses and scenarios.`;
                promptText = prompt + imageInstruction;
            }
            
            promptText += `\n\nOutput dimensions: ${width}x${height}`;

            const contents = [{
                role: "user",
                parts: [{ text: promptText }]
            }];

            // Add uploaded images to the request
            if (uploadedImages && uploadedImages.length > 0) {
                uploadedImages.forEach(img => {
                    contents[0].parts.push({
                        inline_data: {
                            mime_type: img.mimeType || "image/png",
                            data: img.base64
                        }
                    });
                });
            }

            const requestBody = {
                contents: contents,
                generationConfig: {
                    temperature: 1,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 8192,
                }
            };

            const response = await fetch(`${url}?key=${apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();

            // Extract image from response
            const candidate = data.candidates?.[0];
            if (!candidate || !candidate.content || !candidate.content.parts) {
                throw new Error('No image generated in response');
            }

            const part = candidate.content.parts.find(p => p.inlineData);
            if (!part || !part.inlineData) {
                throw new Error('No image data found in response');
            }

            // Convert base64 to blob URL
            const base64Data = part.inlineData.data;
            const mimeType = part.inlineData.mimeType || 'image/png';
            const blob = base64ToBlob(base64Data, mimeType);
            return URL.createObjectURL(blob);
        }

        async function generateSeedreamImage(apiKey, prompt, width, height, uploadedImages = []) {
            // Step 1: Create generation task
            const createTaskUrl = 'https://api.freepik.com/v1/ai/text-to-image/seedream-v4';
            
            // Build prompt text
            let promptText = prompt;
            if (uploadedImages && uploadedImages.length > 0) {
                promptText += ` [Reference images provided for style/character guidance]`;
            }
            
            const requestBody = {
                prompt: promptText,
                width: width,
                height: height,
                // Note: Seedream 4 may not support image inputs directly in text-to-image endpoint
                // You may need to use image-to-image endpoint for reference images
            };

            // Create task
            const createResponse = await fetch(createTaskUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'x-freepik-api-key': apiKey
                },
                body: JSON.stringify(requestBody)
            });

            if (!createResponse.ok) {
                const errorData = await createResponse.json().catch(() => ({}));
                throw new Error(errorData.message || errorData.error || `HTTP ${createResponse.status}: ${createResponse.statusText}`);
            }

            const taskData = await createResponse.json();
            const taskId = taskData.data?.id || taskData.id || taskData.task_id;

            if (!taskId) {
                throw new Error('No task ID returned from Seedream API');
            }

            // Step 2: Poll for task completion
            const statusUrl = `https://api.freepik.com/v1/ai/text-to-image/seedream-v4/${taskId}`;
            const maxAttempts = 60; // 5 minutes max (5 second intervals)
            let attempts = 0;

            while (attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds

                const statusResponse = await fetch(statusUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'x-freepik-api-key': apiKey
                    }
                });

                if (!statusResponse.ok) {
                    const errorData = await statusResponse.json().catch(() => ({}));
                    throw new Error(errorData.message || errorData.error || `HTTP ${statusResponse.status}: ${statusResponse.statusText}`);
                }

                const statusData = await statusResponse.json();
                const status = statusData.data?.status || statusData.status;

                if (status === 'completed' || status === 'success') {
                    // Step 3: Get the image URL
                    const imageUrl = statusData.data?.image_url || statusData.data?.url || statusData.image_url || statusData.url;
                    
                    if (!imageUrl) {
                        throw new Error('No image URL in completed task response');
                    }

                    // Fetch the image and convert to blob URL
                    const imageResponse = await fetch(imageUrl);
                    if (!imageResponse.ok) {
                        throw new Error(`Failed to fetch generated image: ${imageResponse.statusText}`);
                    }
                    
                    const blob = await imageResponse.blob();
                    return URL.createObjectURL(blob);
                } else if (status === 'failed' || status === 'error') {
                    const errorMsg = statusData.data?.error || statusData.error || 'Task failed';
                    throw new Error(`Seedream generation failed: ${errorMsg}`);
                } else if (status === 'processing' || status === 'pending' || status === 'in_progress') {
                    // Continue polling
                    attempts++;
                    continue;
                } else {
                    throw new Error(`Unknown task status: ${status}`);
                }
            }

            throw new Error('Seedream generation timed out after 5 minutes');
        }

        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        }

        function renderResult(prompt, imageUrl, index) {
            const card = document.createElement('div');
            card.className = 'result-card';
            
            // Check if prompt is long enough to need collapse/expand
            const promptLength = prompt.length;
            const needsCollapse = promptLength > 200;
            const promptId = `prompt-${index}`;
            
            card.innerHTML = `
                <img src="${imageUrl}" alt="Generated" class="result-image" />
                <div class="result-info">
                    <div style="margin-bottom: 10px;">
                        <div style="font-size: 10px; color: #999; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Full Prompt:</div>
                        <div id="${promptId}" class="result-prompt ${needsCollapse ? 'collapsed' : ''}">${escapeHtml(prompt)}</div>
                        ${needsCollapse ? `<button class="expand-prompt-btn" onclick="togglePrompt('${promptId}')">Show More</button>` : ''}
                    </div>
                    <div class="result-actions">
                        <button class="btn btn-small" onclick="downloadImage('${imageUrl}', ${index})">Download</button>
                        <button class="btn btn-small btn-secondary" onclick="copyPromptFromResult(${index})">Copy Prompt</button>
                    </div>
                </div>
            `;
            elements.resultsGrid.appendChild(card);
        }

        function togglePrompt(promptId) {
            const promptEl = document.getElementById(promptId);
            const btn = promptEl.nextElementSibling;
            
            if (promptEl.classList.contains('collapsed')) {
                promptEl.classList.remove('collapsed');
                btn.textContent = 'Show Less';
            } else {
                promptEl.classList.add('collapsed');
                btn.textContent = 'Show More';
            }
        }

        // Make togglePrompt available globally
        window.togglePrompt = togglePrompt;

        function renderError(prompt, error, index) {
            const card = document.createElement('div');
            card.className = 'result-card';
            
            // Check if prompt is long enough to need collapse/expand
            const promptLength = prompt.length;
            const needsCollapse = promptLength > 200;
            const promptId = `prompt-error-${index}`;
            
            card.innerHTML = `
                <div style="padding: 40px; text-align: center; color: #dc3545;">
                    <div style="font-size: 48px; margin-bottom: 10px;">‚úó</div>
                    <div style="font-weight: 600; margin-bottom: 5px;">Generation Failed</div>
                    <div style="font-size: 12px; color: #666;">${escapeHtml(error)}</div>
                </div>
                <div class="result-info">
                    <div style="margin-bottom: 10px;">
                        <div style="font-size: 10px; color: #999; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Full Prompt:</div>
                        <div id="${promptId}" class="result-prompt ${needsCollapse ? 'collapsed' : ''}">${escapeHtml(prompt)}</div>
                        ${needsCollapse ? `<button class="expand-prompt-btn" onclick="togglePrompt('${promptId}')">Show More</button>` : ''}
                    </div>
                    <div class="result-actions">
                        <button class="btn btn-small btn-secondary" onclick="copyPromptFromResult(${index})">Copy Prompt</button>
                    </div>
                </div>
            `;
            elements.resultsGrid.appendChild(card);
        }

        // Add PNG text chunk (tEXt) with prompt metadata
        async function addPNGMetadata(imageBlob, prompt) {
            const arrayBuffer = await imageBlob.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            // PNG signature: 89 50 4E 47 0D 0A 1A 0A
            if (uint8Array[0] !== 0x89 || uint8Array[1] !== 0x50 || 
                uint8Array[2] !== 0x4E || uint8Array[3] !== 0x47) {
                return imageBlob; // Not a PNG, return as-is
            }
            
            // Find IEND chunk (last chunk)
            let iendPos = -1;
            for (let i = uint8Array.length - 12; i >= 0; i--) {
                if (uint8Array[i] === 0x49 && uint8Array[i+1] === 0x45 && 
                    uint8Array[i+2] === 0x4E && uint8Array[i+3] === 0x44) {
                    iendPos = i - 4; // Position before length field
                    break;
                }
            }
            
            if (iendPos === -1) return imageBlob; // Couldn't find IEND
            
            // Create tEXt chunk: keyword "Prompt" + null byte + text
            const keyword = 'Prompt';
            const text = prompt;
            const keywordBytes = new TextEncoder().encode(keyword);
            const textBytes = new TextEncoder().encode(text);
            
            // tEXt chunk structure: [length (4 bytes)] [type: tEXt (4 bytes)] [keyword + \0 + text] [CRC (4 bytes)]
            const chunkDataLength = keywordBytes.length + 1 + textBytes.length;
            const chunkLength = 4 + 4 + chunkDataLength + 4; // length + type + data + CRC
            
            // Create new array with tEXt chunk inserted before IEND
            const newArray = new Uint8Array(uint8Array.length + chunkLength);
            newArray.set(uint8Array.slice(0, iendPos), 0);
            
            // Write chunk length (big-endian)
            const view = new DataView(newArray.buffer, iendPos);
            view.setUint32(iendPos, chunkDataLength, false);
            
            // Write chunk type "tEXt"
            newArray[iendPos + 4] = 0x74; // t
            newArray[iendPos + 5] = 0x45; // E
            newArray[iendPos + 6] = 0x58; // X
            newArray[iendPos + 7] = 0x74; // t
            
            // Write keyword + null + text
            let pos = iendPos + 8;
            newArray.set(keywordBytes, pos);
            pos += keywordBytes.length;
            newArray[pos++] = 0; // Null separator
            newArray.set(textBytes, pos);
            pos += textBytes.length;
            
            // Calculate CRC (simplified - using a basic CRC32)
            const crcStart = iendPos + 4;
            const crcEnd = pos;
            let crc = 0xFFFFFFFF;
            for (let i = crcStart; i < crcEnd; i++) {
                crc ^= newArray[i];
                for (let j = 0; j < 8; j++) {
                    crc = (crc >>> 1) ^ (crc & 1 ? 0xEDB88320 : 0);
                }
            }
            crc = (crc ^ 0xFFFFFFFF) >>> 0;
            view.setUint32(pos, crc, false);
            pos += 4;
            
            // Copy IEND chunk
            newArray.set(uint8Array.slice(iendPos), pos);
            
            return new Blob([newArray], { type: 'image/png' });
        }
        
        // Add JPEG EXIF metadata with prompt
        async function addJPEGMetadata(imageBlob, prompt) {
            try {
                const arrayBuffer = await imageBlob.arrayBuffer();
                const binaryString = Array.from(new Uint8Array(arrayBuffer))
                    .map(byte => String.fromCharCode(byte))
                    .join('');
                
                // Get existing EXIF data or create new
                let exifObj = {};
                try {
                    exifObj = piexif.load(binaryString);
                } catch (e) {
                    // No existing EXIF, create new
                    exifObj = { "0th": {}, "Exif": {}, "GPS": {}, "Interop": {}, "1st": {}, "thumbnail": null };
                }
                
                // Add prompt to UserComment in EXIF
                const userComment = JSON.stringify({ prompt: prompt });
                exifObj.Exif[piexif.ExifIFD.UserComment] = userComment;
                
                // Also add to ImageDescription for easier access
                exifObj["0th"][piexif.ImageIFD.ImageDescription] = `AI Generated Image - Prompt: ${prompt.substring(0, 200)}`;
                
                // Insert EXIF data
                const exifStr = piexif.dump(exifObj);
                const newBinaryString = piexif.insert(exifStr, binaryString);
                
                // Convert back to blob
                const newArray = new Uint8Array(newBinaryString.length);
                for (let i = 0; i < newBinaryString.length; i++) {
                    newArray[i] = newBinaryString.charCodeAt(i);
                }
                
                return new Blob([newArray], { type: 'image/jpeg' });
            } catch (error) {
                console.error('Error adding JPEG metadata:', error);
                return imageBlob; // Return original if metadata addition fails
            }
        }
        
        // Make downloadImage available globally
        window.downloadImage = async function(imageUrl, index) {
            try {
                const result = state.results[index];
                if (!result || !result.prompt) {
                    // Fallback to simple download
                    const link = document.createElement('a');
                    link.href = imageUrl;
                    link.download = `batch-image-${index + 1}.png`;
                    link.click();
                    return;
                }
                
                // Fetch the image blob
                const response = await fetch(imageUrl);
                const blob = await response.blob();
                
                let finalBlob = blob;
                const prompt = result.prompt;
                
                // Determine image type and add appropriate metadata
                if (blob.type === 'image/png' || imageUrl.includes('.png')) {
                    finalBlob = await addPNGMetadata(blob, prompt);
                } else if (blob.type === 'image/jpeg' || blob.type === 'image/jpg' || imageUrl.includes('.jpg') || imageUrl.includes('.jpeg')) {
                    finalBlob = await addJPEGMetadata(blob, prompt);
                } else {
                    // Try PNG metadata for unknown types
                    finalBlob = await addPNGMetadata(blob, prompt);
                }
                
                // Create download link
                const url = URL.createObjectURL(finalBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `batch-image-${index + 1}.${blob.type.includes('jpeg') ? 'jpg' : 'png'}`;
                link.click();
                
                // Clean up
                setTimeout(() => URL.revokeObjectURL(url), 100);
            } catch (error) {
                console.error('Error downloading image with metadata:', error);
                // Fallback to simple download
                const link = document.createElement('a');
                link.href = imageUrl;
                link.download = `batch-image-${index + 1}.png`;
                link.click();
            }
        };

        function copyPrompt(prompt) {
            // Unescape the prompt text before copying
            const unescapedPrompt = prompt.replace(/\\'/g, "'").replace(/\\"/g, '"');
            navigator.clipboard.writeText(unescapedPrompt).then(() => {
                alert('Prompt copied to clipboard!');
            });
        }

        function copyPromptFromResult(index) {
            const result = state.results[index];
            if (result && result.prompt) {
                navigator.clipboard.writeText(result.prompt).then(() => {
                    alert('Prompt copied to clipboard!');
                });
            }
        }

        // Make copyPromptFromResult available globally
        window.copyPromptFromResult = copyPromptFromResult;

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============================================
        // History Management
        // ============================================

        // Convert blob URL to base64
        async function blobUrlToBase64(blobUrl) {
            try {
                const response = await fetch(blobUrl);
                const blob = await response.blob();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const base64 = reader.result.split(',')[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error('Error converting blob URL to base64:', error);
                return null;
            }
        }

        // Load history from localStorage
        function loadHistory() {
            const stored = localStorage.getItem('batch-generator-history');
            if (stored) {
                try {
                    state.history = JSON.parse(stored);
                } catch (e) {
                    state.history = [];
                }
            }
            renderHistory();
        }

        // Save history to localStorage with error handling
        function saveHistory() {
            try {
                // Limit history to 50 items to prevent quota issues
                const MAX_HISTORY_ITEMS = 50;
                if (state.history.length > MAX_HISTORY_ITEMS) {
                    state.history = state.history.slice(0, MAX_HISTORY_ITEMS);
                }
                localStorage.setItem('batch-generator-history', JSON.stringify(state.history));
            } catch (error) {
                if (error.name === 'QuotaExceededError' || error.message.includes('quota')) {
                    console.warn('localStorage quota exceeded. Clearing oldest history items...');
                    // Try to save with fewer items
                    if (state.history.length > 10) {
                        state.history = state.history.slice(0, 10);
                        try {
                            localStorage.setItem('batch-generator-history', JSON.stringify(state.history));
                        } catch (e2) {
                            console.error('Still cannot save history. Clearing all history.');
                            state.history = [];
                            localStorage.removeItem('batch-generator-history');
                        }
                    } else {
                        // If still failing with 10 items, clear history
                        console.error('Cannot save history even with reduced items. Clearing history.');
                        state.history = [];
                        localStorage.removeItem('batch-generator-history');
                    }
                } else {
                    console.error('Error saving history:', error);
                }
            }
        }

        // Add item to history
        async function addToHistory(imageUrl, prompt, dimensions) {
            try {
                const imageBase64 = await blobUrlToBase64(imageUrl);
                if (!imageBase64) {
                    console.error('Failed to convert image to base64');
                    return;
                }

                const historyItem = {
                    id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                    imageBase64: imageBase64,
                    prompt: prompt,
                    dimensions: dimensions,
                    timestamp: new Date().toISOString(),
                    selected: false
                };
                state.history.unshift(historyItem); // Add to beginning
                
                // Limit history to 50 items before saving
                const MAX_HISTORY_ITEMS = 50;
                if (state.history.length > MAX_HISTORY_ITEMS) {
                    state.history = state.history.slice(0, MAX_HISTORY_ITEMS);
                }
                
                saveHistory();
                renderHistory();
            } catch (error) {
                console.error('Error adding to history:', error);
                // Continue execution even if history fails
            }
        }

        // Render history grid
        function renderHistory() {
            if (state.history.length === 0) {
                elements.historyGrid.innerHTML = '';
                elements.noHistoryMessage.style.display = 'block';
                return;
            }

            elements.noHistoryMessage.style.display = 'none';
            elements.historyGrid.innerHTML = state.history.map(item => {
                const date = new Date(item.timestamp);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                const promptPreview = item.prompt.length > 100 
                    ? item.prompt.substring(0, 100) + '...' 
                    : item.prompt;
                
                return `
                    <div class="history-item ${item.selected ? 'selected' : ''}" data-id="${item.id}">
                        <input type="checkbox" class="history-item-checkbox" ${item.selected ? 'checked' : ''} 
                               onchange="toggleHistoryItem('${item.id}')" />
                        <img src="data:image/png;base64,${item.imageBase64}" alt="Generated" />
                        <div class="history-item-prompt" title="${escapeHtml(item.prompt)}">${escapeHtml(promptPreview)}</div>
                        <div class="history-item-date">${dateStr}</div>
                    </div>
                `;
            }).join('');
        }

        // Toggle history item selection
        window.toggleHistoryItem = function(id) {
            const item = state.history.find(h => h.id === id);
            if (item) {
                item.selected = !item.selected;
                saveHistory();
                renderHistory();
            }
        };

        // Select all history items
        elements.selectAllBtn.addEventListener('click', () => {
            state.history.forEach(item => item.selected = true);
            saveHistory();
            renderHistory();
        });

        // Deselect all history items
        elements.deselectAllBtn.addEventListener('click', () => {
            state.history.forEach(item => item.selected = false);
            saveHistory();
            renderHistory();
        });

        // Clear history
        elements.clearHistoryBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all history? This cannot be undone.')) {
                state.history = [];
                saveHistory();
                renderHistory();
                alert('History cleared successfully!');
            }
        });

        // Export to PDF
        elements.exportPdfBtn.addEventListener('click', async () => {
            const selected = state.history.filter(item => item.selected);
            
            if (selected.length === 0) {
                alert('Please select at least one item to export');
                return;
            }

            elements.exportPdfBtn.disabled = true;
            elements.exportPdfBtn.textContent = '‚è≥ Generating PDF...';

            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });

                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 15;
                const imageWidth = pageWidth - (margin * 2);
                let yPos = margin;

                for (let i = 0; i < selected.length; i++) {
                    const item = selected[i];
                    
                    // Add new page if not first item
                    if (i > 0) {
                        pdf.addPage();
                        yPos = margin;
                    }

                    // Convert base64 to image
                    const img = new Image();
                    img.src = `data:image/png;base64,${item.imageBase64}`;
                    
                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            try {
                                // Calculate image height to fit width
                                const aspectRatio = img.height / img.width;
                                const imageHeight = imageWidth * aspectRatio;
                                
                                // Check if image fits on page
                                if (yPos + imageHeight > pageHeight - margin - 40) {
                                    pdf.addPage();
                                    yPos = margin;
                                }
                                
                                // Add image
                                pdf.addImage(img, 'PNG', margin, yPos, imageWidth, imageHeight);
                                yPos += imageHeight + 10;
                                
                                // Add prompt text
                                const promptLines = pdf.splitTextToSize(item.prompt, imageWidth);
                                const promptHeight = promptLines.length * 5;
                                
                                // Check if prompt fits on page
                                if (yPos + promptHeight > pageHeight - margin) {
                                    pdf.addPage();
                                    yPos = margin;
                                }
                                
                                pdf.setFontSize(10);
                                pdf.text('Prompt:', margin, yPos);
                                yPos += 5;
                                pdf.setFontSize(8);
                                pdf.text(promptLines, margin, yPos);
                                yPos += promptHeight + 10;
                                
                                resolve();
                            } catch (err) {
                                reject(err);
                            }
                        };
                        img.onerror = () => {
                            reject(new Error(`Failed to load image ${i + 1}`));
                        };
                    });
                }

                pdf.save(`batch-generator-${Date.now()}.pdf`);
                alert(`PDF exported successfully with ${selected.length} item(s)!`);
            } catch (error) {
                console.error('PDF export error:', error);
                alert(`Error exporting PDF: ${error.message}`);
            } finally {
                elements.exportPdfBtn.disabled = false;
                elements.exportPdfBtn.textContent = 'üìÑ Export PDF';
            }
        });

        // Export to ZIP
        elements.exportZipBtn.addEventListener('click', async () => {
            const selected = state.history.filter(item => item.selected);
            
            if (selected.length === 0) {
                alert('Please select at least one item to export');
                return;
            }

            elements.exportZipBtn.disabled = true;
            elements.exportZipBtn.textContent = '‚è≥ Creating ZIP...';

            try {
                const zip = new JSZip();
                const promptsText = [];

                for (let i = 0; i < selected.length; i++) {
                    const item = selected[i];
                    const date = new Date(item.timestamp);
                    const filename = `image-${i + 1}-${date.getTime()}.png`;
                    
                    // Add image to zip
                    const imageData = atob(item.imageBase64);
                    const imageBytes = new Uint8Array(imageData.length);
                    for (let j = 0; j < imageData.length; j++) {
                        imageBytes[j] = imageData.charCodeAt(j);
                    }
                    zip.file(filename, imageBytes);
                    
                    // Add prompt to text array
                    promptsText.push(`--- Image ${i + 1}: ${filename} ---\n${item.prompt}\n`);
                }

                // Add prompts text file
                zip.file('prompts.txt', promptsText.join('\n\n'));

                // Generate and download ZIP
                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `batch-generator-${Date.now()}.zip`;
                a.click();
                URL.revokeObjectURL(url);

                alert(`ZIP exported successfully with ${selected.length} item(s)!`);
            } catch (error) {
                console.error('ZIP export error:', error);
                alert(`Error exporting ZIP: ${error.message}`);
            } finally {
                elements.exportZipBtn.disabled = false;
                elements.exportZipBtn.textContent = 'üì¶ Export ZIP';
            }
        });

        // Initialize history on load
        loadHistory();

        // Add start button after parsing
        elements.parseBtn.addEventListener('click', () => {
            setTimeout(() => {
                if (state.prompts.length > 0 && !document.getElementById('startBtn')) {
                    const startBtn = document.createElement('button');
                    startBtn.id = 'startBtn';
                    startBtn.className = 'btn';
                    startBtn.textContent = 'üöÄ Start Generation';
                    startBtn.style.marginTop = '15px';
                    startBtn.addEventListener('click', startGeneration);
                    elements.parseBtn.parentElement.appendChild(startBtn);
                }
            }, 100);
        });
    </script>
</body>
</html>


