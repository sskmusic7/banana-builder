<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üçå Batch Prompt Generator - AI Image Generator</title>
    <style>
        :root {
            --primary: #667eea;
            --primary-dark: #5568d3;
            --secondary: #764ba2;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --info: #17a2b8;
            --bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --shadow: 0 20px 60px rgba(0,0,0,0.3);
            --shadow-hover: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: var(--bg-gradient);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: var(--shadow);
            padding: 40px;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .home-btn {
            display: inline-block;
            margin-bottom: 20px;
            padding: 8px 16px;
            background: var(--primary);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: transform 0.2s ease;
        }

        .home-btn:hover {
            transform: translateY(-2px);
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 700;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            border: 1px solid #e9ecef;
        }

        .section-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary);
        }

        input[type="text"],
        input[type="password"],
        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary);
        }

        .btn {
            background: var(--bg-gradient);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            display: inline-block;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-hover);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-danger {
            background: var(--danger);
        }

        .btn-success {
            background: var(--success);
        }

        .prompt-list {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .prompt-item {
            padding: 10px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid var(--primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .prompt-item-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .delete-prompt-btn {
            background: var(--danger);
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s ease;
        }

        .delete-prompt-btn:hover {
            background: #c82333;
        }

        .prompt-item.processing {
            border-left-color: var(--info);
            background: #e7f3ff;
        }

        .prompt-item.success {
            border-left-color: var(--success);
            background: #d4edda;
        }

        .prompt-item.error {
            border-left-color: var(--danger);
            background: #f8d7da;
        }

        .prompt-text {
            flex: 1;
            font-size: 13px;
            color: #333;
            word-break: break-word;
            margin-right: 10px;
        }

        .prompt-status {
            font-size: 12px;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .status-pending {
            color: #666;
        }

        .status-processing {
            color: var(--info);
            background: #d1ecf1;
        }

        .status-success {
            color: var(--success);
            background: #d4edda;
        }

        .status-error {
            color: var(--danger);
            background: #f8d7da;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .result-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .result-card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-hover);
        }

        .result-image {
            width: 100%;
            height: 300px;
            object-fit: cover;
            background: #f8f9fa;
        }

        .result-info {
            padding: 15px;
        }

        .result-prompt {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
            word-break: break-word;
            line-height: 1.6;
        }

        .result-prompt.collapsed {
            max-height: 120px;
            overflow: hidden;
            position: relative;
        }

        .result-prompt.collapsed::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(to bottom, transparent, white);
        }

        .expand-prompt-btn {
            background: transparent;
            border: none;
            color: var(--primary);
            font-size: 11px;
            cursor: pointer;
            padding: 4px 0;
            margin-top: 5px;
            text-decoration: underline;
            font-weight: 600;
        }

        .expand-prompt-btn:hover {
            color: var(--primary-dark);
        }

        .result-actions {
            display: flex;
            gap: 8px;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--bg-gradient);
            transition: width 0.3s ease;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: #f8f9fa;
            padding: 15px 20px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary);
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .dimension-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .file-upload-area {
            border: 3px dashed #ddd;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .file-upload-area:hover {
            border-color: var(--primary);
            background: #f8f9ff;
        }

        .file-upload-area.dragover {
            border-color: var(--primary);
            background: #e7f3ff;
        }

        .file-upload-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .file-upload-area input[type="file"] {
            display: none;
        }

        .image-previews {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .image-preview-item {
            position: relative;
            background: #f8f9fa;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #e9ecef;
        }

        .image-preview-item img {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }

        .image-preview-item .remove-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .image-preview-item .image-info {
            padding: 8px;
            font-size: 11px;
            color: #666;
            word-break: break-word;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            .dimension-group {
                grid-template-columns: 1fr;
            }

            .results-grid {
                grid-template-columns: 1fr;
            }

            .image-previews {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="/" class="home-btn">‚Üê Home</a>
        
        <header>
            <h1>üçå Batch Prompt Generator</h1>
            <p class="subtitle">Generate multiple images from prompts automatically</p>
        </header>

        <div class="section">
            <div class="section-title">‚öôÔ∏è Settings</div>
            
            <div class="form-group">
                <label>Gemini API Key *</label>
                <input type="password" id="apiKey" placeholder="Enter your Gemini API key" />
            </div>

            <div class="form-group">
                <label>Model</label>
                <select id="modelSelect">
                    <option value="gemini-2.5-flash-image">Gemini 2.5 Flash Image</option>
                    <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                    <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                    <option value="seedream-4">Seedream 4 (Freepik)</option>
                </select>
            </div>

            <div class="form-group" id="seedreamApiKeyGroup" style="display: none;">
                <label>Freepik API Key *</label>
                <input type="password" id="seedreamApiKey" placeholder="Enter your Freepik API key" />
                <p style="font-size: 12px; color: #666; margin-top: 5px;">Get your API key from <a href="https://developers.freepik.com/" target="_blank">Freepik Developers</a></p>
            </div>

            <div class="form-group dimension-group">
                <div>
                    <label>Width</label>
                    <input type="number" id="width" value="1024" min="256" max="2048" step="64" />
                </div>
                <div>
                    <label>Height</label>
                    <input type="number" id="height" value="1024" min="256" max="2048" step="64" />
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">üì∑ Reference Images (Optional)</div>
            <div class="form-group">
                <label>Upload 1-3 images to guide generation (e.g., person, style reference)</label>
                <div class="file-upload-area" id="fileUploadArea">
                    <div class="file-upload-icon">üì§</div>
                    <p><strong>Click to upload</strong> or drag and drop</p>
                    <p style="color: #666; font-size: 0.9em; margin-top: 5px;">JPG, PNG, WebP (Max 10MB each, up to 3 images)</p>
                    <input type="file" id="imageInput" accept="image/*" multiple />
                </div>
                <div class="image-previews" id="imagePreviews"></div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">üìù Prompts</div>
            
            <div class="form-group">
                <label>Enter prompts (numbered items, double newlines, or one per line)</label>
                <textarea id="promptsInput" rows="10" placeholder="Paste your prompts here. Supports:&#10;&#10;1. Numbered prompts (1., 2., 3., etc.)&#10;2. Double newlines between prompts&#10;3. One prompt per line&#10;&#10;Commas within prompts are preserved."></textarea>
            </div>

            <div class="form-group">
                <label>Extra Prompt Guidance (Optional)</label>
                <textarea id="extraPromptGuidance" rows="3" placeholder="Add extra instructions that will be appended to all prompts (e.g., 'all images in NYC', 'use golden hour lighting', etc.)"></textarea>
                <p style="font-size: 12px; color: #666; margin-top: 5px;">This text will be automatically appended to the end of each generated prompt.</p>
            </div>

            <div id="promptList" class="prompt-list" style="display: none;"></div>

            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="btn" id="parseBtn">Parse Prompts</button>
                <button class="btn btn-secondary" id="clearBtn">Clear</button>
            </div>
        </div>

        <div id="progressSection" style="display: none;">
            <div class="section">
                <div class="section-title">üìä Progress</div>
                
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Total</div>
                        <div class="stat-value" id="totalCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Completed</div>
                        <div class="stat-value" id="completedCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Failed</div>
                        <div class="stat-value" id="failedCount">0</div>
                    </div>
                </div>

                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>

                <div style="margin-top: 15px;">
                    <button class="btn btn-danger" id="stopBtn">Stop Generation</button>
                </div>
            </div>
        </div>

        <div id="resultsSection" style="display: none;">
            <div class="section">
                <div class="section-title">üé® Generated Images</div>
                
                <div style="margin-bottom: 15px;">
                    <button class="btn btn-success" id="downloadAllBtn">Download All Images</button>
                </div>

                <div class="results-grid" id="resultsGrid"></div>
            </div>
        </div>
    </div>

    <script>
        const state = {
            prompts: [],
            results: [],
            isProcessing: false,
            shouldStop: false,
            currentIndex: 0,
            uploadedImages: [] // Array of {base64, mimeType, name, preview}
        };

        const elements = {
            apiKey: document.getElementById('apiKey'),
            modelSelect: document.getElementById('modelSelect'),
            seedreamApiKey: document.getElementById('seedreamApiKey'),
            seedreamApiKeyGroup: document.getElementById('seedreamApiKeyGroup'),
            width: document.getElementById('width'),
            height: document.getElementById('height'),
            promptsInput: document.getElementById('promptsInput'),
            extraPromptGuidance: document.getElementById('extraPromptGuidance'),
            promptList: document.getElementById('promptList'),
            parseBtn: document.getElementById('parseBtn'),
            clearBtn: document.getElementById('clearBtn'),
            progressSection: document.getElementById('progressSection'),
            resultsSection: document.getElementById('resultsSection'),
            totalCount: document.getElementById('totalCount'),
            completedCount: document.getElementById('completedCount'),
            failedCount: document.getElementById('failedCount'),
            progressFill: document.getElementById('progressFill'),
            stopBtn: document.getElementById('stopBtn'),
            downloadAllBtn: document.getElementById('downloadAllBtn'),
            resultsGrid: document.getElementById('resultsGrid'),
            fileUploadArea: document.getElementById('fileUploadArea'),
            imageInput: document.getElementById('imageInput'),
            imagePreviews: document.getElementById('imagePreviews')
        };

        // Load saved API keys and settings
        const savedKey = localStorage.getItem('batch-generator-api-key');
        if (savedKey) {
            elements.apiKey.value = savedKey;
        }
        const savedSeedreamKey = localStorage.getItem('batch-generator-seedream-api-key');
        if (savedSeedreamKey) {
            elements.seedreamApiKey.value = savedSeedreamKey;
        }
        const savedExtraGuidance = localStorage.getItem('batch-generator-extra-guidance');
        if (savedExtraGuidance) {
            elements.extraPromptGuidance.value = savedExtraGuidance;
        }

        // Save API keys and settings on change
        elements.apiKey.addEventListener('input', () => {
            localStorage.setItem('batch-generator-api-key', elements.apiKey.value);
        });
        elements.seedreamApiKey.addEventListener('input', () => {
            localStorage.setItem('batch-generator-seedream-api-key', elements.seedreamApiKey.value);
        });
        elements.extraPromptGuidance.addEventListener('input', () => {
            localStorage.setItem('batch-generator-extra-guidance', elements.extraPromptGuidance.value);
        });

        // Show/hide Seedream API key field based on model selection
        elements.modelSelect.addEventListener('change', () => {
            if (elements.modelSelect.value === 'seedream-4') {
                elements.seedreamApiKeyGroup.style.display = 'block';
                elements.apiKey.closest('.form-group').style.display = 'none';
            } else {
                elements.seedreamApiKeyGroup.style.display = 'none';
                elements.apiKey.closest('.form-group').style.display = 'block';
            }
        });

        // Initialize on load
        if (elements.modelSelect.value === 'seedream-4') {
            elements.seedreamApiKeyGroup.style.display = 'block';
            elements.apiKey.closest('.form-group').style.display = 'none';
        }

        // Image upload handlers
        elements.fileUploadArea.addEventListener('click', () => {
            elements.imageInput.click();
        });

        elements.fileUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.fileUploadArea.classList.add('dragover');
        });

        elements.fileUploadArea.addEventListener('dragleave', () => {
            elements.fileUploadArea.classList.remove('dragover');
        });

        elements.fileUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.fileUploadArea.classList.remove('dragover');
            
            const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
            if (files.length > 0) {
                handleImageUploads(files);
            }
        });

        elements.imageInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/'));
            if (files.length > 0) {
                handleImageUploads(files);
            }
        });

        function handleImageUploads(files) {
            // Limit to 3 images total
            const remainingSlots = 3 - state.uploadedImages.length;
            const filesToProcess = files.slice(0, remainingSlots);

            if (files.length > remainingSlots) {
                alert(`You can only upload up to 3 images. Processing first ${remainingSlots} file(s).`);
            }

            filesToProcess.forEach(file => {
                if (file.size > 10 * 1024 * 1024) {
                    alert(`File ${file.name} is too large (max 10MB). Skipping.`);
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    const matches = dataUrl.match(/^data:(.+);base64,(.+)$/);
                    if (matches) {
                        state.uploadedImages.push({
                            base64: matches[2],
                            mimeType: matches[1],
                            name: file.name,
                            preview: dataUrl
                        });
                        renderImagePreviews();
                    }
                };
                reader.readAsDataURL(file);
            });
        }

        function removeImage(index) {
            state.uploadedImages.splice(index, 1);
            renderImagePreviews();
        }

        function renderImagePreviews() {
            if (state.uploadedImages.length === 0) {
                elements.imagePreviews.innerHTML = '';
                return;
            }

            elements.imagePreviews.innerHTML = state.uploadedImages.map((img, index) => `
                <div class="image-preview-item">
                    <button class="remove-btn" onclick="removeImage(${index})" title="Remove image">√ó</button>
                    <img src="${img.preview}" alt="Preview" />
                    <div class="image-info">${escapeHtml(img.name)}</div>
                </div>
            `).join('');
        }

        // Make removeImage available globally
        window.removeImage = removeImage;

        elements.parseBtn.addEventListener('click', () => {
            let text = elements.promptsInput.value.trim();
            if (!text) {
                alert('Please enter some prompts');
                return;
            }

            // Smart parsing: Handle numbered prompts, double newlines, or single newlines
            let prompts = [];
            
            // First, remove "--- PROMPT X: filename ---" header lines
            text = text.replace(/^---\s*PROMPT\s+\d+:\s*[^\n]+?\s*---\s*/gmi, '');
            
            // Method 1: Check for numbered prompts (1., 2., 3., etc.)
            // Use a regex to match numbered sections: number + title + content (until next number or end)
            const numberedMatches = text.match(/\d+\.\s+[^\n]*(?:\n(?!\d+\.\s)[^\n]*)*/g);
            if (numberedMatches && numberedMatches.length > 0) {
                // Extract content from each numbered section
                prompts = numberedMatches.map(match => {
                    // Remove the number prefix, keep title and content, replace newlines with spaces
                    const fullPrompt = match
                        .replace(/^\d+\.\s+/, '') // Remove "1. " prefix
                        .replace(/\n+/g, ' ')     // Replace newlines with spaces
                        .replace(/\s+/g, ' ')      // Normalize multiple spaces
                        .trim();
                    return fullPrompt;
                }).filter(p => {
                    // Filter out empty prompts and lines that are ONLY "---" separators
                    return p.length > 0 && !p.match(/^---\s*$/);
                });
            } else {
                // Method 2: Split by double newlines (paragraph breaks)
                if (text.includes('\n\n')) {
                    prompts = text
                        .split(/\n\n+/)
                        .map(p => p.trim().replace(/\n/g, ' ')) // Replace single newlines with spaces
                        .filter(p => {
                            // Filter out empty prompts and lines that are ONLY "---" separators
                            return p.length > 0 && !p.match(/^---\s*$/);
                        });
                } else {
                    // Method 3: Split by single newlines (one per line)
                    prompts = text
                        .split(/\n+/)
                        .map(p => p.trim())
                        .filter(p => {
                            // Filter out empty prompts and lines that are ONLY "---" separators
                            return p.length > 0 && !p.match(/^---\s*$/);
                        });
                }
            }

            if (prompts.length === 0) {
                alert('No valid prompts found');
                return;
            }

            state.prompts = prompts.map((prompt, index) => ({
                id: index,
                text: prompt,
                status: 'pending',
                result: null,
                error: null
            }));

            renderPromptList();
            elements.promptList.style.display = 'block';
        });

        elements.clearBtn.addEventListener('click', () => {
            elements.promptsInput.value = '';
            state.prompts = [];
            state.results = [];
            state.uploadedImages = [];
            elements.promptList.style.display = 'none';
            elements.progressSection.style.display = 'none';
            elements.resultsSection.style.display = 'none';
            renderPromptList();
            renderImagePreviews();
            // Note: We don't clear extraPromptGuidance on clear, as it's a master setting
        });

        elements.stopBtn.addEventListener('click', () => {
            state.shouldStop = true;
            state.isProcessing = false;
            elements.stopBtn.disabled = true;
        });

        elements.downloadAllBtn.addEventListener('click', () => {
            const successfulResults = state.results.filter(r => r.imageUrl);
            if (successfulResults.length === 0) {
                alert('No images to download');
                return;
            }

            successfulResults.forEach((result, index) => {
                const link = document.createElement('a');
                link.href = result.imageUrl;
                link.download = `batch-image-${index + 1}.png`;
                link.click();
            });
        });

        function renderPromptList() {
            elements.promptList.innerHTML = state.prompts.map((prompt, index) => {
                const statusClass = `status-${prompt.status}`;
                const canDelete = prompt.status === 'pending' && !state.isProcessing;
                return `
                    <div class="prompt-item ${prompt.status}">
                        <div class="prompt-text">${escapeHtml(prompt.text)}</div>
                        <div class="prompt-item-actions">
                            <div class="prompt-status ${statusClass}">
                                ${prompt.status === 'pending' ? '‚è≥ Pending' : 
                                  prompt.status === 'processing' ? '<span class="loading"></span> Processing' :
                                  prompt.status === 'success' ? '‚úì Success' :
                                  prompt.status === 'error' ? '‚úó Error' : ''}
                            </div>
                            ${canDelete ? `<button class="delete-prompt-btn" onclick="deletePrompt(${index})" title="Delete prompt">√ó</button>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            if (state.prompts.length > 0) {
                elements.progressSection.style.display = 'block';
                updateProgress();
            }
        }

        function deletePrompt(index) {
            if (state.isProcessing) {
                alert('Cannot delete prompts while generation is in progress');
                return;
            }
            state.prompts.splice(index, 1);
            // Re-index prompts
            state.prompts = state.prompts.map((p, i) => ({ ...p, id: i }));
            renderPromptList();
        }

        // Make deletePrompt available globally
        window.deletePrompt = deletePrompt;

        function updateProgress() {
            const total = state.prompts.length;
            const completed = state.results.filter(r => r.success).length;
            const failed = state.results.filter(r => !r.success).length;

            elements.totalCount.textContent = total;
            elements.completedCount.textContent = completed;
            elements.failedCount.textContent = failed;

            const progress = total > 0 ? ((completed + failed) / total) * 100 : 0;
            elements.progressFill.style.width = `${progress}%`;
        }

        async function startGeneration() {
            const selectedModel = elements.modelSelect.value;
            
            if (selectedModel === 'seedream-4') {
                if (!elements.seedreamApiKey.value.trim()) {
                    alert('Please enter your Freepik API key');
                    return;
                }
            } else {
                if (!elements.apiKey.value.trim()) {
                    alert('Please enter your Gemini API key');
                    return;
                }
            }

            if (state.prompts.length === 0) {
                alert('Please parse prompts first');
                return;
            }

            state.isProcessing = true;
            state.shouldStop = false;
            state.currentIndex = 0;
            state.results = [];
            elements.stopBtn.disabled = false;
            elements.resultsSection.style.display = 'block';
            elements.resultsGrid.innerHTML = '';

            for (let i = 0; i < state.prompts.length; i++) {
                if (state.shouldStop) {
                    break;
                }

                state.currentIndex = i;
                const prompt = state.prompts[i];
                prompt.status = 'processing';
                renderPromptList();

                try {
                    const apiKey = elements.modelSelect.value === 'seedream-4' 
                        ? elements.seedreamApiKey.value 
                        : elements.apiKey.value;
                    
                    // Append extra prompt guidance if provided
                    let finalPrompt = prompt.text;
                    const extraGuidance = elements.extraPromptGuidance.value.trim();
                    if (extraGuidance) {
                        finalPrompt = `${finalPrompt} ${extraGuidance}`;
                    }
                    
                    const imageUrl = await generateImage(
                        apiKey,
                        finalPrompt,
                        parseInt(elements.width.value),
                        parseInt(elements.height.value),
                        state.uploadedImages
                    );

                    prompt.status = 'success';
                    prompt.result = imageUrl;

                    state.results.push({
                        prompt: finalPrompt, // Store the full prompt with extra guidance
                        originalPrompt: prompt.text, // Store original for reference
                        imageUrl: imageUrl,
                        success: true
                    });

                    renderResult(finalPrompt, imageUrl, state.results.length - 1);
                } catch (error) {
                    prompt.status = 'error';
                    prompt.error = error.message;

                    // Append extra prompt guidance to error display too
                    let errorPrompt = prompt.text;
                    const extraGuidance = elements.extraPromptGuidance.value.trim();
                    if (extraGuidance) {
                        errorPrompt = `${errorPrompt} ${extraGuidance}`;
                    }
                    
                    state.results.push({
                        prompt: errorPrompt,
                        error: error.message,
                        success: false
                    });

                    renderError(errorPrompt, error.message, state.results.length - 1);
                }

                renderPromptList();
                updateProgress();

                // Small delay between requests to avoid rate limiting
                if (i < state.prompts.length - 1 && !state.shouldStop) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }

            state.isProcessing = false;
            elements.stopBtn.disabled = true;
        }

        async function generateImage(apiKey, prompt, width, height, uploadedImages = []) {
            const model = elements.modelSelect.value;
            
            // Handle Seedream 4 API (async task-based)
            if (model === 'seedream-4') {
                return await generateSeedreamImage(apiKey, prompt, width, height, uploadedImages);
            }
            
            // Handle Gemini API (synchronous)
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;

            // Build the prompt text
            let promptText = prompt;
            
            // If reference images are provided, add instructions to use them for likeness only
            if (uploadedImages && uploadedImages.length > 0) {
                const imageInstruction = `\n\nIMPORTANT: The uploaded reference image(s) are provided for subject likeness, appearance, facial features, and styling reference ONLY. DO NOT copy the pose, position, body arrangement, camera angle, or action from the reference images. Instead, follow the pose, position, action, and composition described in the prompt text above. Use the reference images solely to maintain consistent subject appearance and features across different poses and scenarios.`;
                promptText = prompt + imageInstruction;
            }
            
            promptText += `\n\nOutput dimensions: ${width}x${height}`;

            const contents = [{
                role: "user",
                parts: [{ text: promptText }]
            }];

            // Add uploaded images to the request
            if (uploadedImages && uploadedImages.length > 0) {
                uploadedImages.forEach(img => {
                    contents[0].parts.push({
                        inline_data: {
                            mime_type: img.mimeType || "image/png",
                            data: img.base64
                        }
                    });
                });
            }

            const requestBody = {
                contents: contents,
                generationConfig: {
                    temperature: 1,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 8192,
                }
            };

            const response = await fetch(`${url}?key=${apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();

            // Extract image from response
            const candidate = data.candidates?.[0];
            if (!candidate || !candidate.content || !candidate.content.parts) {
                throw new Error('No image generated in response');
            }

            const part = candidate.content.parts.find(p => p.inlineData);
            if (!part || !part.inlineData) {
                throw new Error('No image data found in response');
            }

            // Convert base64 to blob URL
            const base64Data = part.inlineData.data;
            const mimeType = part.inlineData.mimeType || 'image/png';
            const blob = base64ToBlob(base64Data, mimeType);
            return URL.createObjectURL(blob);
        }

        async function generateSeedreamImage(apiKey, prompt, width, height, uploadedImages = []) {
            // Step 1: Create generation task
            const createTaskUrl = 'https://api.freepik.com/v1/ai/text-to-image/seedream-v4';
            
            // Build prompt text
            let promptText = prompt;
            if (uploadedImages && uploadedImages.length > 0) {
                promptText += ` [Reference images provided for style/character guidance]`;
            }
            
            const requestBody = {
                prompt: promptText,
                width: width,
                height: height,
                // Note: Seedream 4 may not support image inputs directly in text-to-image endpoint
                // You may need to use image-to-image endpoint for reference images
            };

            // Create task
            const createResponse = await fetch(createTaskUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'x-freepik-api-key': apiKey
                },
                body: JSON.stringify(requestBody)
            });

            if (!createResponse.ok) {
                const errorData = await createResponse.json().catch(() => ({}));
                throw new Error(errorData.message || errorData.error || `HTTP ${createResponse.status}: ${createResponse.statusText}`);
            }

            const taskData = await createResponse.json();
            const taskId = taskData.data?.id || taskData.id || taskData.task_id;

            if (!taskId) {
                throw new Error('No task ID returned from Seedream API');
            }

            // Step 2: Poll for task completion
            const statusUrl = `https://api.freepik.com/v1/ai/text-to-image/seedream-v4/${taskId}`;
            const maxAttempts = 60; // 5 minutes max (5 second intervals)
            let attempts = 0;

            while (attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds

                const statusResponse = await fetch(statusUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'x-freepik-api-key': apiKey
                    }
                });

                if (!statusResponse.ok) {
                    const errorData = await statusResponse.json().catch(() => ({}));
                    throw new Error(errorData.message || errorData.error || `HTTP ${statusResponse.status}: ${statusResponse.statusText}`);
                }

                const statusData = await statusResponse.json();
                const status = statusData.data?.status || statusData.status;

                if (status === 'completed' || status === 'success') {
                    // Step 3: Get the image URL
                    const imageUrl = statusData.data?.image_url || statusData.data?.url || statusData.image_url || statusData.url;
                    
                    if (!imageUrl) {
                        throw new Error('No image URL in completed task response');
                    }

                    // Fetch the image and convert to blob URL
                    const imageResponse = await fetch(imageUrl);
                    if (!imageResponse.ok) {
                        throw new Error(`Failed to fetch generated image: ${imageResponse.statusText}`);
                    }
                    
                    const blob = await imageResponse.blob();
                    return URL.createObjectURL(blob);
                } else if (status === 'failed' || status === 'error') {
                    const errorMsg = statusData.data?.error || statusData.error || 'Task failed';
                    throw new Error(`Seedream generation failed: ${errorMsg}`);
                } else if (status === 'processing' || status === 'pending' || status === 'in_progress') {
                    // Continue polling
                    attempts++;
                    continue;
                } else {
                    throw new Error(`Unknown task status: ${status}`);
                }
            }

            throw new Error('Seedream generation timed out after 5 minutes');
        }

        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        }

        function renderResult(prompt, imageUrl, index) {
            const card = document.createElement('div');
            card.className = 'result-card';
            
            // Check if prompt is long enough to need collapse/expand
            const promptLength = prompt.length;
            const needsCollapse = promptLength > 200;
            const promptId = `prompt-${index}`;
            
            card.innerHTML = `
                <img src="${imageUrl}" alt="Generated" class="result-image" />
                <div class="result-info">
                    <div style="margin-bottom: 10px;">
                        <div style="font-size: 10px; color: #999; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Full Prompt:</div>
                        <div id="${promptId}" class="result-prompt ${needsCollapse ? 'collapsed' : ''}">${escapeHtml(prompt)}</div>
                        ${needsCollapse ? `<button class="expand-prompt-btn" onclick="togglePrompt('${promptId}')">Show More</button>` : ''}
                    </div>
                    <div class="result-actions">
                        <button class="btn btn-small" onclick="downloadImage('${imageUrl}', ${index})">Download</button>
                        <button class="btn btn-small btn-secondary" onclick="copyPromptFromResult(${index})">Copy Prompt</button>
                    </div>
                </div>
            `;
            elements.resultsGrid.appendChild(card);
        }

        function togglePrompt(promptId) {
            const promptEl = document.getElementById(promptId);
            const btn = promptEl.nextElementSibling;
            
            if (promptEl.classList.contains('collapsed')) {
                promptEl.classList.remove('collapsed');
                btn.textContent = 'Show Less';
            } else {
                promptEl.classList.add('collapsed');
                btn.textContent = 'Show More';
            }
        }

        // Make togglePrompt available globally
        window.togglePrompt = togglePrompt;

        function renderError(prompt, error, index) {
            const card = document.createElement('div');
            card.className = 'result-card';
            
            // Check if prompt is long enough to need collapse/expand
            const promptLength = prompt.length;
            const needsCollapse = promptLength > 200;
            const promptId = `prompt-error-${index}`;
            
            card.innerHTML = `
                <div style="padding: 40px; text-align: center; color: #dc3545;">
                    <div style="font-size: 48px; margin-bottom: 10px;">‚úó</div>
                    <div style="font-weight: 600; margin-bottom: 5px;">Generation Failed</div>
                    <div style="font-size: 12px; color: #666;">${escapeHtml(error)}</div>
                </div>
                <div class="result-info">
                    <div style="margin-bottom: 10px;">
                        <div style="font-size: 10px; color: #999; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Full Prompt:</div>
                        <div id="${promptId}" class="result-prompt ${needsCollapse ? 'collapsed' : ''}">${escapeHtml(prompt)}</div>
                        ${needsCollapse ? `<button class="expand-prompt-btn" onclick="togglePrompt('${promptId}')">Show More</button>` : ''}
                    </div>
                    <div class="result-actions">
                        <button class="btn btn-small btn-secondary" onclick="copyPromptFromResult(${index})">Copy Prompt</button>
                    </div>
                </div>
            `;
            elements.resultsGrid.appendChild(card);
        }

        function downloadImage(imageUrl, index) {
            const link = document.createElement('a');
            link.href = imageUrl;
            link.download = `batch-image-${index + 1}.png`;
            link.click();
        }

        function copyPrompt(prompt) {
            // Unescape the prompt text before copying
            const unescapedPrompt = prompt.replace(/\\'/g, "'").replace(/\\"/g, '"');
            navigator.clipboard.writeText(unescapedPrompt).then(() => {
                alert('Prompt copied to clipboard!');
            });
        }

        function copyPromptFromResult(index) {
            const result = state.results[index];
            if (result && result.prompt) {
                navigator.clipboard.writeText(result.prompt).then(() => {
                    alert('Prompt copied to clipboard!');
                });
            }
        }

        // Make copyPromptFromResult available globally
        window.copyPromptFromResult = copyPromptFromResult;

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Add start button after parsing
        elements.parseBtn.addEventListener('click', () => {
            setTimeout(() => {
                if (state.prompts.length > 0 && !document.getElementById('startBtn')) {
                    const startBtn = document.createElement('button');
                    startBtn.id = 'startBtn';
                    startBtn.className = 'btn';
                    startBtn.textContent = 'üöÄ Start Generation';
                    startBtn.style.marginTop = '15px';
                    startBtn.addEventListener('click', startGeneration);
                    elements.parseBtn.parentElement.appendChild(startBtn);
                }
            }, 100);
        });
    </script>
</body>
</html>


