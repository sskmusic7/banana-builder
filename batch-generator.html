<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üçå Batch Prompt Generator - AI Image Generator</title>
    <!-- Libraries for PDF and ZIP export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Library for image metadata (EXIF) -->
    <script src="https://cdn.jsdelivr.net/npm/piexifjs@2.0.0/piexif.js"></script>
    <style>
        :root {
            --primary: #667eea;
            --primary-dark: #5568d3;
            --secondary: #764ba2;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --info: #17a2b8;
            --bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --shadow: 0 20px 60px rgba(0,0,0,0.3);
            --shadow-hover: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: var(--bg-gradient);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: var(--shadow);
            padding: 40px;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .home-btn {
            display: inline-block;
            margin-bottom: 20px;
            padding: 8px 16px;
            background: var(--primary);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: transform 0.2s ease;
        }

        .home-btn:hover {
            transform: translateY(-2px);
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 700;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            border: 1px solid #e9ecef;
        }

        .section-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary);
        }

        input[type="text"],
        input[type="password"],
        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary);
        }

        .btn {
            background: var(--bg-gradient);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            display: inline-block;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-hover);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-danger {
            background: var(--danger);
        }

        .btn-success {
            background: var(--success);
        }

        .prompt-list {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .prompt-item {
            padding: 10px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid var(--primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .prompt-item-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .delete-prompt-btn {
            background: var(--danger);
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s ease;
        }

        .delete-prompt-btn:hover {
            background: #c82333;
        }

        .prompt-item.processing {
            border-left-color: var(--info);
            background: #e7f3ff;
        }

        .prompt-item.success {
            border-left-color: var(--success);
            background: #d4edda;
        }

        .prompt-item.error {
            border-left-color: var(--danger);
            background: #f8d7da;
        }

        .prompt-text {
            flex: 1;
            font-size: 13px;
            color: #333;
            word-break: break-word;
            margin-right: 10px;
        }

        .prompt-status {
            font-size: 12px;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .status-pending {
            color: #666;
        }

        .status-processing {
            color: var(--info);
            background: #d1ecf1;
        }

        .status-success {
            color: var(--success);
            background: #d4edda;
        }

        .status-error {
            color: var(--danger);
            background: #f8d7da;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .result-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .result-card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-hover);
        }

        .result-image {
            width: 100%;
            height: 300px;
            object-fit: cover;
            background: #f8f9fa;
        }

        .result-info {
            padding: 15px;
        }

        .result-prompt {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
            word-break: break-word;
            line-height: 1.6;
        }

        .result-prompt.collapsed {
            max-height: 120px;
            overflow: hidden;
            position: relative;
        }

        .result-prompt.collapsed::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(to bottom, transparent, white);
        }

        .expand-prompt-btn {
            background: transparent;
            border: none;
            color: var(--primary);
            font-size: 11px;
            cursor: pointer;
            padding: 4px 0;
            margin-top: 5px;
            text-decoration: underline;
            font-weight: 600;
        }

        .expand-prompt-btn:hover {
            color: var(--primary-dark);
        }

        .history-section {
            margin-top: 40px;
            padding-top: 40px;
            border-top: 2px solid #e9ecef;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .history-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .history-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .history-item {
            background: white;
            border: 2px solid #ddd;
            border-radius: 12px;
            padding: 10px;
            position: relative;
            transition: all 0.3s;
        }

        .history-item:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .history-item.selected {
            border-color: var(--primary);
            background: #f0f0ff;
        }

        .history-item-checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            cursor: pointer;
            z-index: 10;
        }

        .history-item img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .history-item-prompt {
            font-size: 0.85em;
            color: #666;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        .history-item-date {
            font-size: 0.75em;
            color: #999;
            margin-top: 5px;
        }

        .select-all-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .result-actions {
            display: flex;
            gap: 8px;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--bg-gradient);
            transition: width 0.3s ease;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: #f8f9fa;
            padding: 15px 20px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary);
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .dimension-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .file-upload-area {
            border: 3px dashed #ddd;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .file-upload-area:hover {
            border-color: var(--primary);
            background: #f8f9ff;
        }

        .file-upload-area.dragover {
            border-color: var(--primary);
            background: #e7f3ff;
        }

        .file-upload-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .file-upload-area input[type="file"] {
            display: none;
        }

        .image-previews {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .image-preview-item {
            position: relative;
            background: #f8f9fa;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #e9ecef;
        }

        .image-preview-item img {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }

        .image-preview-item .remove-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .image-preview-item .image-info {
            padding: 8px;
            font-size: 11px;
            color: #666;
            word-break: break-word;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            .dimension-group {
                grid-template-columns: 1fr;
            }

            .results-grid {
                grid-template-columns: 1fr;
            }

            .image-previews {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="/" class="home-btn">‚Üê Home</a>
        
        <header>
            <h1>üçå Batch Prompt Generator</h1>
            <p class="subtitle">Generate multiple images from prompts automatically</p>
        </header>

        <div class="section">
            <div class="section-title">‚öôÔ∏è Settings</div>
            
            <div class="form-group">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="useSharedGeminiKey" style="width: auto; margin: 0;">
                    <span>Use Shared API Key (Beta Testing)</span>
                </label>
                <div id="sharedKeyStatus" style="font-size: 12px; color: #666; margin-top: 5px; display: none;">
                    <span id="sharedKeyStatusText">Checking availability...</span>
                </div>
            </div>
            
            <div class="form-group" id="apiKeyGroup">
                <label>Gemini API Key *</label>
                <input type="password" id="apiKey" placeholder="Enter your Gemini API key" />
                <p style="font-size: 12px; color: #666; margin-top: 5px;">Leave empty if using shared key above</p>
            </div>

            <div class="form-group">
                <label>Model</label>
                <select id="modelSelect">
                    <option value="gemini-2.5-flash-image">Gemini 2.5 Flash Image</option>
                    <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                    <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                    <option value="seedream-4">Seedream 4 (Freepik)</option>
                </select>
            </div>

            <div class="form-group" id="seedreamApiKeyGroup" style="display: none;">
                <label>Freepik API Key *</label>
                <input type="password" id="seedreamApiKey" placeholder="Enter your Freepik API key" />
                <p style="font-size: 12px; color: #666; margin-top: 5px;">Get your API key from <a href="https://developers.freepik.com/" target="_blank">Freepik Developers</a></p>
            </div>

            <div class="form-group dimension-group">
                <div>
                    <label>Width</label>
                    <input type="number" id="width" value="1024" min="256" max="2048" step="64" />
                </div>
                <div>
                    <label>Height</label>
                    <input type="number" id="height" value="1024" min="256" max="2048" step="64" />
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">üì∑ Reference Images (Optional)</div>
            <div class="form-group">
                <label>Upload 1-3 images to guide generation (e.g., person, style reference)</label>
                <div class="file-upload-area" id="fileUploadArea">
                    <div class="file-upload-icon">üì§</div>
                    <p><strong>Click to upload</strong> or drag and drop</p>
                    <p style="color: #666; font-size: 0.9em; margin-top: 5px;">JPG, PNG, WebP (Max 10MB each, up to 3 images)</p>
                    <input type="file" id="imageInput" accept="image/*" multiple />
                </div>
                <div class="image-previews" id="imagePreviews"></div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">üìù Prompts</div>
            
            <div class="form-group">
                <label>Enter prompts (JSON, markdown, numbered items, double newlines, or one per line)</label>
                <textarea id="promptsInput" rows="10" placeholder="Paste your prompts here. Supports:&#10;&#10;1. JSON format with prompts array (pose, outfit, setting fields)&#10;2. Markdown format with ## PROMPT X: sections&#10;3. Numbered prompts (1., 2., 3., etc.)&#10;4. Double newlines between prompts&#10;5. One prompt per line&#10;&#10;Commas within prompts are preserved."></textarea>
            </div>

            <div class="form-group">
                <label>Extra Prompt Guidance (Optional)</label>
                <textarea id="extraPromptGuidance" rows="3" placeholder="Add extra instructions that will be appended to all prompts (e.g., 'all images in NYC', 'use golden hour lighting', etc.)"></textarea>
                <p style="font-size: 12px; color: #666; margin-top: 5px;">This text will be automatically appended to the end of each generated prompt.</p>
            </div>

            <div class="form-group">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="enableEnhancement" checked style="width: auto; margin: 0;">
                    <span>ü§ñ AI Prompt Enhancement (Trained on Guide Docs)</span>
                </label>
                <p style="font-size: 12px; color: #666; margin-top: 5px; margin-left: 30px;">Select which enhancements to apply to your prompts:</p>
                
                <div id="enhancementOptions" style="display: block; margin-top: 15px; margin-left: 30px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
                            <input type="checkbox" id="enhanceBodyShape" checked style="width: auto; margin: 0;">
                            <span>Body Shapes</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
                            <input type="checkbox" id="enhanceRealism" checked style="width: auto; margin: 0;">
                            <span>Ultra-Realism</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
                            <input type="checkbox" id="enhanceCameraAngle" checked style="width: auto; margin: 0;">
                            <span>Camera Angles</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
                            <input type="checkbox" id="enhanceLuxury" style="width: auto; margin: 0;">
                            <span>Luxury Aesthetic</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
                            <input type="checkbox" id="enhanceDating" style="width: auto; margin: 0;">
                            <span>Dating Appeal</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
                            <input type="checkbox" id="preventAIStare" checked style="width: auto; margin: 0;">
                            <span>üö´ Prevent AI Stare (Natural Candid)</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
                            <input type="checkbox" id="enableRealismEnhancement" checked style="width: auto; margin: 0;">
                            <span>üé® Auto Realism Enhancement (Skin/Lighting)</span>
                        </label>
                    </div>
                    <p style="font-size: 11px; color: #666; margin-top: 10px; margin-left: 0;">
                        <strong>Note:</strong> "Auto Realism Enhancement" adds detailed skin, lighting, and color instructions to every prompt. If you're experiencing weird coloring or unwanted elements, try disabling this.
                    </p>
                </div>
            </div>

            <div id="promptList" class="prompt-list" style="display: none;"></div>

            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="btn" id="parseBtn">Parse Prompts</button>
                <button class="btn btn-secondary" id="clearBtn">Clear</button>
            </div>
        </div>

        <div id="progressSection" style="display: none;">
            <div class="section">
                <div class="section-title">üìä Progress</div>
                
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Total</div>
                        <div class="stat-value" id="totalCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Completed</div>
                        <div class="stat-value" id="completedCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Failed</div>
                        <div class="stat-value" id="failedCount">0</div>
                    </div>
                </div>

                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>

                <div style="margin-top: 15px;">
                    <button class="btn btn-danger" id="stopBtn">Stop Generation</button>
                </div>
            </div>
        </div>

        <div id="resultsSection" style="display: none;">
            <div class="section">
                <div class="section-title">üé® Generated Images</div>
                
                <div style="margin-bottom: 15px;">
                    <button class="btn btn-success" id="downloadAllBtn">Download All Images</button>
                </div>

                <div class="results-grid" id="resultsGrid"></div>
            </div>
        </div>

        <!-- History Section -->
        <div class="history-section section" id="historySection">
            <div class="history-header">
                <h2 style="margin: 0; font-size: 1.5em;">üìö Generation History</h2>
                <div class="history-controls">
                    <div class="select-all-controls">
                        <button class="btn" id="selectAllBtn" style="background: #6c757d; color: white;">Select All</button>
                        <button class="btn" id="deselectAllBtn" style="background: #6c757d; color: white;">Deselect All</button>
                    </div>
                    <button class="btn btn-success" id="exportPdfBtn">üìÑ Export PDF</button>
                    <button class="btn btn-primary" id="exportZipBtn">üì¶ Export ZIP</button>
                    <button class="btn btn-danger" id="clearHistoryBtn">üóëÔ∏è Clear History</button>
                </div>
            </div>
            <div class="history-grid" id="historyGrid">
                <!-- History items will be added here dynamically -->
            </div>
            <p id="noHistoryMessage" style="text-align: center; color: #999; padding: 20px; display: none;">
                No generation history yet. Generate some images to see them here!
            </p>
        </div>
    </div>

    <script>
        const state = {
            prompts: [],
            results: [],
            isProcessing: false,
            shouldStop: false,
            currentIndex: 0,
            uploadedImages: [], // Array of {base64, mimeType, name, preview}
            history: [] // Array of {id, imageBase64, prompt, timestamp, selected}
        };

        const elements = {
            apiKey: document.getElementById('apiKey'),
            modelSelect: document.getElementById('modelSelect'),
            seedreamApiKey: document.getElementById('seedreamApiKey'),
            seedreamApiKeyGroup: document.getElementById('seedreamApiKeyGroup'),
            width: document.getElementById('width'),
            height: document.getElementById('height'),
            promptsInput: document.getElementById('promptsInput'),
            extraPromptGuidance: document.getElementById('extraPromptGuidance'),
            promptList: document.getElementById('promptList'),
            parseBtn: document.getElementById('parseBtn'),
            clearBtn: document.getElementById('clearBtn'),
            progressSection: document.getElementById('progressSection'),
            resultsSection: document.getElementById('resultsSection'),
            totalCount: document.getElementById('totalCount'),
            completedCount: document.getElementById('completedCount'),
            failedCount: document.getElementById('failedCount'),
            progressFill: document.getElementById('progressFill'),
            stopBtn: document.getElementById('stopBtn'),
            downloadAllBtn: document.getElementById('downloadAllBtn'),
            resultsGrid: document.getElementById('resultsGrid'),
            fileUploadArea: document.getElementById('fileUploadArea'),
            imageInput: document.getElementById('imageInput'),
            imagePreviews: document.getElementById('imagePreviews'),
            historySection: document.getElementById('historySection'),
            historyGrid: document.getElementById('historyGrid'),
            noHistoryMessage: document.getElementById('noHistoryMessage'),
            selectAllBtn: document.getElementById('selectAllBtn'),
            deselectAllBtn: document.getElementById('deselectAllBtn'),
            exportPdfBtn: document.getElementById('exportPdfBtn'),
            exportZipBtn: document.getElementById('exportZipBtn'),
            clearHistoryBtn: document.getElementById('clearHistoryBtn')
        };

        // Check for shared API keys availability
        let sharedKeysAvailable = { gemini: false, seedream: false };
        async function checkSharedKeys() {
            try {
                const response = await fetch('/.netlify/functions/check-shared-key');
                if (response.ok) {
                    sharedKeysAvailable = await response.json();
                    console.log('Shared keys available:', sharedKeysAvailable);
                    const statusDiv = document.getElementById('sharedKeyStatus');
                    const statusText = document.getElementById('sharedKeyStatusText');
                    const useSharedCheckbox = document.getElementById('useSharedGeminiKey');
                    
                    if (statusDiv && statusText && useSharedCheckbox) {
                        if (sharedKeysAvailable.gemini) {
                            statusDiv.style.display = 'block';
                            statusText.textContent = '‚úì Shared Gemini API key available';
                            statusText.style.color = '#28a745';
                            useSharedCheckbox.disabled = false;
                            // Auto-check if user hasn't set a preference
                            const savedPreference = localStorage.getItem('batch-generator-use-shared-key');
                            if (savedPreference === null) {
                                useSharedCheckbox.checked = true;
                                localStorage.setItem('batch-generator-use-shared-key', 'true');
                            }
                        } else {
                            statusDiv.style.display = 'block';
                            statusText.textContent = '‚úó Shared API key not configured';
                            statusText.style.color = '#dc3545';
                            useSharedCheckbox.disabled = true;
                            useSharedCheckbox.checked = false;
                        }
                    }
                } else {
                    console.error('Failed to check shared keys:', response.status, response.statusText);
                }
            } catch (error) {
                console.error('Error checking shared keys:', error);
                const statusDiv = document.getElementById('sharedKeyStatus');
                const statusText = document.getElementById('sharedKeyStatusText');
                if (statusDiv && statusText) {
                    statusDiv.style.display = 'block';
                    statusText.textContent = '‚úó Unable to check shared key availability';
                    statusText.style.color = '#dc3545';
                }
            }
        }
        
        // Check on page load
        checkSharedKeys();

        // Load saved API keys and settings
        const savedKey = localStorage.getItem('batch-generator-api-key');
        const savedUseSharedKey = localStorage.getItem('batch-generator-use-shared-key') === 'true';
        if (savedKey) {
            elements.apiKey.value = savedKey;
        }
        const savedSeedreamKey = localStorage.getItem('batch-generator-seedream-api-key');
        if (savedSeedreamKey) {
            elements.seedreamApiKey.value = savedSeedreamKey;
        }
        const savedExtraGuidance = localStorage.getItem('batch-generator-extra-guidance');
        if (savedExtraGuidance) {
            elements.extraPromptGuidance.value = savedExtraGuidance;
        }
        
        // Set up shared key checkbox
        const useSharedGeminiKeyCheckbox = document.getElementById('useSharedGeminiKey');
        if (useSharedGeminiKeyCheckbox) {
            useSharedGeminiKeyCheckbox.checked = savedUseSharedKey;
            
            // Toggle API key input visibility
            const toggleApiKeyInput = () => {
                const apiKeyGroup = document.getElementById('apiKeyGroup');
                if (apiKeyGroup) {
                    if (useSharedGeminiKeyCheckbox.checked && sharedKeysAvailable.gemini) {
                        apiKeyGroup.style.display = 'none';
                    } else {
                        apiKeyGroup.style.display = 'block';
                    }
                }
            };
            
            // Wait for shared keys check to complete, then toggle
            setTimeout(toggleApiKeyInput, 500);
            
            useSharedGeminiKeyCheckbox.addEventListener('change', () => {
                localStorage.setItem('batch-generator-use-shared-key', useSharedGeminiKeyCheckbox.checked);
                toggleApiKeyInput();
            });
        }

        // Save API keys and settings on change
        elements.apiKey.addEventListener('input', () => {
            localStorage.setItem('batch-generator-api-key', elements.apiKey.value);
        });
        elements.seedreamApiKey.addEventListener('input', () => {
            localStorage.setItem('batch-generator-seedream-api-key', elements.seedreamApiKey.value);
        });
        elements.extraPromptGuidance.addEventListener('input', () => {
            localStorage.setItem('batch-generator-extra-guidance', elements.extraPromptGuidance.value);
        });

        // Show/hide Seedream API key field based on model selection
        elements.modelSelect.addEventListener('change', () => {
            if (elements.modelSelect.value === 'seedream-4') {
                elements.seedreamApiKeyGroup.style.display = 'block';
                elements.apiKey.closest('.form-group').style.display = 'none';
            } else {
                elements.seedreamApiKeyGroup.style.display = 'none';
                elements.apiKey.closest('.form-group').style.display = 'block';
            }
        });

        // Initialize on load
        if (elements.modelSelect.value === 'seedream-4') {
            elements.seedreamApiKeyGroup.style.display = 'block';
            elements.apiKey.closest('.form-group').style.display = 'none';
        }

        // Load enhancement settings
        const savedEnhancementEnabled = localStorage.getItem('batch-generator-enhancement-enabled');
        // Default to true if not set, otherwise use saved value
        const enhancementEnabled = savedEnhancementEnabled === null ? true : savedEnhancementEnabled === 'true';
        const savedEnhancementOptions = JSON.parse(localStorage.getItem('batch-generator-enhancement-options') || '{"bodyShape":true,"realism":true,"cameraAngle":true,"luxury":false,"dating":false}');
        const savedPreventAIStare = localStorage.getItem('batch-generator-prevent-ai-stare') !== 'false'; // Default to true
        
        const enableEnhancementCheckbox = document.getElementById('enableEnhancement');
        const enhancementOptionsDiv = document.getElementById('enhancementOptions');
        const preventAIStareCheckbox = document.getElementById('preventAIStare');
        
        if (enableEnhancementCheckbox) {
            enableEnhancementCheckbox.checked = enhancementEnabled;
            enhancementOptionsDiv.style.display = 'block'; // Always show checkboxes so users can select individually
            
            // Set individual option checkboxes
            document.getElementById('enhanceBodyShape').checked = savedEnhancementOptions.bodyShape !== false;
            document.getElementById('enhanceRealism').checked = savedEnhancementOptions.realism !== false;
            document.getElementById('enhanceCameraAngle').checked = savedEnhancementOptions.cameraAngle !== false;
            document.getElementById('enhanceLuxury').checked = savedEnhancementOptions.luxury === true;
            document.getElementById('enhanceDating').checked = savedEnhancementOptions.dating === true;
            
            // Set prevent AI stare checkbox (default to true)
            if (preventAIStareCheckbox) {
                preventAIStareCheckbox.checked = savedPreventAIStare;
                preventAIStareCheckbox.addEventListener('change', () => {
                    localStorage.setItem('batch-generator-prevent-ai-stare', preventAIStareCheckbox.checked);
                });
            }
            
            // Set realism enhancement checkbox (default to true)
            const enableRealismEnhancementCheckbox = document.getElementById('enableRealismEnhancement');
            const savedRealismEnhancement = localStorage.getItem('batch-generator-realism-enhancement') !== 'false'; // Default to true
            if (enableRealismEnhancementCheckbox) {
                enableRealismEnhancementCheckbox.checked = savedRealismEnhancement;
                enableRealismEnhancementCheckbox.addEventListener('change', () => {
                    localStorage.setItem('batch-generator-realism-enhancement', enableRealismEnhancementCheckbox.checked);
                });
            }
            
            // Toggle enhancement options visibility
            enableEnhancementCheckbox.addEventListener('change', () => {
                enhancementOptionsDiv.style.display = enableEnhancementCheckbox.checked ? 'block' : 'none';
                localStorage.setItem('batch-generator-enhancement-enabled', enableEnhancementCheckbox.checked);
            });
            
            // Save individual option changes
            ['enhanceBodyShape', 'enhanceRealism', 'enhanceCameraAngle', 'enhanceLuxury', 'enhanceDating'].forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener('change', () => {
                        const options = {
                            bodyShape: document.getElementById('enhanceBodyShape').checked,
                            realism: document.getElementById('enhanceRealism').checked,
                            cameraAngle: document.getElementById('enhanceCameraAngle').checked,
                            luxury: document.getElementById('enhanceLuxury').checked,
                            dating: document.getElementById('enhanceDating').checked
                        };
                        localStorage.setItem('batch-generator-enhancement-options', JSON.stringify(options));
                    });
                }
            });
        }

        // Image upload handlers
        elements.fileUploadArea.addEventListener('click', () => {
            elements.imageInput.click();
        });

        elements.fileUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.fileUploadArea.classList.add('dragover');
        });

        elements.fileUploadArea.addEventListener('dragleave', () => {
            elements.fileUploadArea.classList.remove('dragover');
        });

        elements.fileUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.fileUploadArea.classList.remove('dragover');
            
            const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
            if (files.length > 0) {
                handleImageUploads(files);
            }
        });

        elements.imageInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/'));
            if (files.length > 0) {
                handleImageUploads(files);
            }
        });

        function handleImageUploads(files) {
            // Limit to 3 images total
            const remainingSlots = 3 - state.uploadedImages.length;
            const filesToProcess = files.slice(0, remainingSlots);

            if (files.length > remainingSlots) {
                alert(`You can only upload up to 3 images. Processing first ${remainingSlots} file(s).`);
            }

            filesToProcess.forEach(file => {
                if (file.size > 10 * 1024 * 1024) {
                    alert(`File ${file.name} is too large (max 10MB). Skipping.`);
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    const matches = dataUrl.match(/^data:(.+);base64,(.+)$/);
                    if (matches) {
                        state.uploadedImages.push({
                            base64: matches[2],
                            mimeType: matches[1],
                            name: file.name,
                            preview: dataUrl
                        });
                        renderImagePreviews();
                    }
                };
                reader.readAsDataURL(file);
            });
        }

        function removeImage(index) {
            state.uploadedImages.splice(index, 1);
            renderImagePreviews();
        }

        function renderImagePreviews() {
            if (state.uploadedImages.length === 0) {
                elements.imagePreviews.innerHTML = '';
                return;
            }

            elements.imagePreviews.innerHTML = state.uploadedImages.map((img, index) => `
                <div class="image-preview-item">
                    <button class="remove-btn" onclick="removeImage(${index})" title="Remove image">√ó</button>
                    <img src="${img.preview}" alt="Preview" />
                    <div class="image-info">${escapeHtml(img.name)}</div>
                </div>
            `).join('');
        }

        // Make removeImage available globally
        window.removeImage = removeImage;

        // ============================================
        // KNOWLEDGE BASE SYSTEM - Trained on Guide Docs
        // ============================================
        const knowledgeBase = {
            bodyShapes: {
                hourglass: {
                    classic: "Bust and hips equal width. Waist dramatically narrow (25%+ smaller). Shoulders align with hips. Full, rounded bust. Pronounced S-curve waist-to-hip transition. Thighs soft with gradual taper. Buttocks naturally rounded and lifted.",
                    top: "Upper body broader than hips. Bust exceeds hip width by 1-2 inches. Fuller bust (C+ cup). Wide shoulders with developed deltoids. Defined waist despite upper prominence. Narrow hips and sleek thighs.",
                    bottom: "Hips exceed bust by 1-2 inches. Dramatic hip width with shelf-like projection. Full, rounded thighs. Pronounced buttocks volume and lift. Narrow shoulders and modest bust.",
                    neat: "Subtle hourglass with refined curves. Bust and hips balanced without drama. Gentle waist taper. Streamlined, athletic physique. Streamlined thighs."
                },
                triangular: {
                    pear: "Hips substantially wider than shoulders (2+ inches). Narrow shoulders, small-moderate bust. Dramatic hip flare. Full, rounded thighs. Substantial buttocks volume.",
                    spoon: "Extreme hip projection with 'shelf' effect. Hips up to 10 inches larger than waist. Pronounced upper hip widening. Very full thighs from hip junction. Substantial buttocks projection.",
                    inverted: "Shoulders significantly wider than hips (3+ inches). Broad shoulder span. Narrow hips with minimal projection. Sleek, streamlined thighs. Compact athletic buttocks.",
                    diamond: "Midsection widest point of body. Narrow shoulders and hips. Small-moderate bust. Full, rounded abdomen projects forward. Slender arms and legs."
                },
                straight: {
                    rectangle: "Bust, waist, hips near-identical measurements. Minimal waist indentation. Consistent body width shoulder-to-hip. Moderate bust. Straight vertical lines.",
                    athletic: "Rectangle proportions enhanced with visible musculature. Defined shoulders with deltoid development. Athletic build with toned physique. Toned arms with bicep/tricep visibility.",
                    banana: "Extremely straight with minimal curves. Near-identical measurements throughout. Very narrow waist without taper. Slender thighs. Minimal buttocks projection."
                },
                rounded: {
                    apple: "Central torso fullest region. Generous bust. Rounded, forward-projecting abdomen. Minimal waist definition. Narrow hips relative to midsection.",
                    oval: "Generous proportions throughout entire frame. Substantial bust. Full, rounded hips. Full thighs throughout length. Generous buttocks projection."
                }
            },
            realism: {
                skin: "Ultra-realistic skin texture with natural pores, subtle imperfections, and authentic skin tone variation. Natural skin translucency showing underlying vascular structures. Realistic skin surface with micro-details including fine lines, natural blemishes, and authentic skin grain.",
                lighting: "Natural lighting with realistic shadows, highlights, and ambient occlusion. Soft, diffused lighting that mimics natural light sources. Realistic light falloff and shadow depth. Natural color temperature matching time of day and environment.",
                camera: "Authentic camera characteristics including natural depth of field, realistic bokeh, and authentic lens distortion. Natural camera shake and motion blur where appropriate. Realistic sensor noise and grain matching camera type.",
                details: "Micro-details including realistic hair texture, natural fabric wrinkles, authentic surface reflections, and realistic environmental interactions. Natural wear patterns and authentic material properties."
            },
            cameraAngles: {
                eyeLevel: "Eye-level shot, straight-on perspective creating direct engaging view. Natural human perspective matching typical eye height.",
                lowAngle: "Low-angle shot from below subject, creating powerful, commanding presence. Camera positioned below eye level looking upward.",
                highAngle: "High-angle shot from above subject, creating more intimate or vulnerable perspective. Camera positioned above eye level looking downward.",
                threeQuarter: "Three-quarter shot capturing subject from angle between front and side. Shows depth and dimension while maintaining facial recognition.",
                profile: "Profile shot from side, showing subject's silhouette and side features. Emphasizes jawline and side profile.",
                closeUp: "Close-up shot focusing on face or specific feature. Intimate perspective emphasizing details and expressions.",
                medium: "Medium shot from waist up, balanced perspective showing upper body and face. Standard portrait framing.",
                fullBody: "Full-body shot capturing entire figure from head to toe. Shows complete outfit and body proportions."
            },
            luxury: {
                aesthetic: "Luxury aesthetic with refined elegance, sophisticated styling, and premium quality appearance. High-end fashion sensibility with attention to detail and quality materials.",
                environment: "Upscale environments including luxury hotels, high-end boutiques, exclusive venues, and premium locations. Sophisticated settings with refined architecture and elegant decor.",
                styling: "Premium styling with designer clothing, luxury accessories, and sophisticated fashion choices. Attention to detail in outfit coordination and high-end fashion presentation."
            },
            dating: {
                appeal: "Appealing presentation optimized for dating context. Natural, approachable appearance with authentic charm and genuine appeal.",
                confidence: "Confident, engaging presence with natural charisma. Approachable confidence that feels authentic and attractive.",
                authenticity: "Authentic, genuine appearance that feels real and relatable. Natural expressions and authentic personality visible."
            },
            antiAIStare: {
                gazeDirections: [
                    "looking off to the side",
                    "gazing toward the left",
                    "looking down and to the right",
                    "eyes directed away from camera",
                    "glancing over shoulder",
                    "looking at something off-camera",
                    "caught mid-glance",
                    "eyes closed momentarily",
                    "looking ahead down the path",
                    "gazing contemplatively away"
                ],
                headAngles: [
                    "head tilted slightly left",
                    "head angled to the right",
                    "chin tilted down",
                    "face turned 3/4 away from camera",
                    "head turned over shoulder",
                    "semi-profile view",
                    "profile view",
                    "head angled away from straight-on position"
                ],
                midActions: [
                    "mid-laugh, genuine laughter",
                    "subtle smirk forming",
                    "caught mid-sentence, mouth slightly open",
                    "natural soft smile, not forced",
                    "pensive expression, lost in thought",
                    "subtle eye squint from natural smile",
                    "relaxed jaw, mouth slightly parted",
                    "authentic expression of joy",
                    "contemplative look",
                    "candid reaction",
                    "caught mid-gesture",
                    "mid-stride walking"
                ],
                catchlights: "cinematic catchlight in eyes, sparkle in eyes from natural light, light reflecting in pupils, natural eye moisture and light reflection, catchlight from window light, subtle eye highlights",
                cameraAngles: [
                    "shot from slightly off-axis angle",
                    "camera positioned 15-20 degrees to the left",
                    "three-quarter view, not straight-on",
                    "over-the-shoulder perspective",
                    "side angle capturing profile",
                    "low angle looking up",
                    "high angle looking down",
                    "off-axis camera angle, not centered composition"
                ],
                photographyStyle: "Candid street photography aesthetic, Henri Cartier-Bresson style decisive moment, photojournalism approach, documentary photography, fly-on-the-wall perspective, unposed moment, stolen shot aesthetic, natural human behavior captured",
                bodyLanguage: "Mid-motion, body slightly turned away from camera. Natural weight shift onto one leg. Hands in motion, not posed. Shoulders relaxed and asymmetrical. Caught mid-gesture. Dynamic stance showing movement. Authentic body positioning, not staged.",
                technicalSpecs: "Deep depth of field keeping both subject AND background in sharp focus, no artificial bokeh, natural environmental context visible, f/8-f/11 aperture equivalent, realistic focus plane, natural light only, ambient light captured naturally, raw iPhone photo quality, unfiltered and authentic",
                negativePrompts: "--no dead stare, blank expression, looking directly at camera, posed portrait, symmetrical face, perfect symmetry, statue-like pose, frozen expression, studio portrait gaze, headshot pose, lifeless eyes, no catchlights, flat eyes, direct eye contact, centered composition, straight-on angle, model pose, fashion shoot stare, AI generated look, robotic expression, uncanny valley, perfect skin, plastic skin, over-smoothed face, artificial lighting, studio background blur, fake bokeh"
            }
        };

        // Prompt Enhancement Function
        function enhancePrompt(prompt, options = {}) {
            let enhanced = prompt;
            const {
                injectBodyShape = false,
                injectRealism = false,
                injectCameraAngle = false,
                injectLuxury = false,
                injectDating = false,
                preventAIStare = false
            } = options;

            // Detect body shape mentions and enhance
            if (injectBodyShape) {
                const bodyShapeKeywords = {
                    hourglass: ['hourglass', 'curvy', 'curves'],
                    pear: ['pear', 'triangle', 'wide hips'],
                    athletic: ['athletic', 'toned', 'muscular', 'fit'],
                    straight: ['straight', 'rectangle', 'column'],
                    apple: ['apple', 'round', 'full']
                };

                for (const [shape, keywords] of Object.entries(bodyShapeKeywords)) {
                    if (keywords.some(kw => prompt.toLowerCase().includes(kw))) {
                        if (shape === 'hourglass' && !enhanced.includes('S-curve')) {
                            enhanced += ` ${knowledgeBase.bodyShapes.hourglass.classic}`;
                        } else if (shape === 'pear' && !enhanced.includes('hip flare')) {
                            enhanced += ` ${knowledgeBase.bodyShapes.triangular.pear}`;
                        } else if (shape === 'athletic' && !enhanced.includes('musculature')) {
                            enhanced += ` ${knowledgeBase.bodyShapes.straight.athletic}`;
                        }
                        break;
                    }
                }
            }

            // Inject realism enhancements
            if (injectRealism) {
                if (!enhanced.includes('realistic') && !enhanced.includes('ultra-realistic')) {
                    enhanced += ` ${knowledgeBase.realism.skin} ${knowledgeBase.realism.lighting}`;
                }
            }

            // Enhance camera angle descriptions
            if (injectCameraAngle) {
                const angleKeywords = {
                    eyeLevel: ['eye-level', 'straight-on', 'direct'],
                    lowAngle: ['low-angle', 'from below'],
                    highAngle: ['high-angle', 'from above'],
                    closeUp: ['close-up', 'closeup', 'close'],
                    medium: ['medium shot', 'waist up'],
                    fullBody: ['full body', 'full-body', 'fullbody']
                };

                for (const [angle, keywords] of Object.entries(angleKeywords)) {
                    if (keywords.some(kw => prompt.toLowerCase().includes(kw))) {
                        if (!enhanced.includes(knowledgeBase.cameraAngles[angle].substring(0, 50))) {
                            enhanced += ` ${knowledgeBase.cameraAngles[angle]}`;
                        }
                        break;
                    }
                }
            }

            // Inject luxury aesthetic
            if (injectLuxury) {
                if (!enhanced.includes('luxury') && !enhanced.includes('premium') && !enhanced.includes('high-end')) {
                    enhanced += ` ${knowledgeBase.luxury.aesthetic} ${knowledgeBase.luxury.styling}`;
                }
            }

            // Inject dating appeal
            if (injectDating) {
                if (!enhanced.includes('appealing') && !enhanced.includes('attractive')) {
                    enhanced += ` ${knowledgeBase.dating.appeal} ${knowledgeBase.dating.authenticity}`;
                }
            }

            // Prevent AI Stare - CRITICAL for natural, candid realism
            if (preventAIStare) {
                // Check if prompt already has AI stare prevention
                const hasAIStarePrevention = enhanced.toLowerCase().includes('looking away') || 
                    enhanced.toLowerCase().includes('gazing off') ||
                    enhanced.toLowerCase().includes('not looking at camera') ||
                    enhanced.toLowerCase().includes('candid moment');
                
                // Check for AI stare red flags
                const hasAIStareFlags = enhanced.toLowerCase().includes('looking at camera') ||
                    enhanced.toLowerCase().includes('direct gaze') ||
                    enhanced.toLowerCase().includes('eye contact with viewer') ||
                    enhanced.toLowerCase().includes('facing camera') ||
                    enhanced.toLowerCase().includes('centered in frame') ||
                    enhanced.toLowerCase().includes('posed portrait');
                
                if (!hasAIStarePrevention || hasAIStareFlags) {
                    // Random selection function
                    const random = (arr) => arr[Math.floor(Math.random() * arr.length)];
                    
                    // Build anti-AI stare additions
                    const gazeDirection = random(knowledgeBase.antiAIStare.gazeDirections);
                    const headAngle = random(knowledgeBase.antiAIStare.headAngles);
                    const midAction = random(knowledgeBase.antiAIStare.midActions);
                    const cameraAngle = random(knowledgeBase.antiAIStare.cameraAngles);
                    
                    // Remove AI stare red flags if present
                    enhanced = enhanced
                        .replace(/\blooking at camera\b/gi, 'looking away from camera')
                        .replace(/\bdirect gaze\b/gi, 'gaze directed away')
                        .replace(/\beye contact with viewer\b/gi, 'eyes directed away from viewer')
                        .replace(/\bfacing camera\b/gi, 'facing away from camera')
                        .replace(/\bcentered in frame\b/gi, 'offset in frame')
                        .replace(/\bposed portrait\b/gi, 'candid portrait');
                    
                    // Add anti-AI stare elements
                    const antiAIAdditions = `${gazeDirection}. ${headAngle}. ${midAction}. ${knowledgeBase.antiAIStare.catchlights}. ${cameraAngle}. ${knowledgeBase.antiAIStare.bodyLanguage}. ${knowledgeBase.antiAIStare.photographyStyle}. ${knowledgeBase.antiAIStare.technicalSpecs}. Natural asymmetry in facial features and pose. Candid moment captured, subject not aware of camera.`;
                    
                    enhanced += ` ${antiAIAdditions}`;
                    
                    // Add negative prompts if not already present
                    if (!enhanced.includes('--no dead stare') && !enhanced.includes('negative prompt')) {
                        enhanced += ` ${knowledgeBase.antiAIStare.negativePrompts}`;
                    }
                }
            }

            return enhanced.trim();
        }

        // ============================================
        // END KNOWLEDGE BASE SYSTEM
        // ============================================

        elements.parseBtn.addEventListener('click', () => {
            let text = elements.promptsInput.value.trim();
            if (!text) {
                alert('Please enter some prompts');
                return;
            }

            // Smart parsing: Handle JSON, markdown, numbered prompts, double newlines, or single newlines
            let prompts = [];
            let referenceInstructions = '';
            
            // Method 0: Check for JSON format first
            try {
                const jsonData = JSON.parse(text);
                if (jsonData && jsonData.prompts && Array.isArray(jsonData.prompts)) {
                    // Handle reference instructions
                    if (jsonData.reference_instructions) {
                        referenceInstructions = jsonData.reference_instructions;
                        // Optionally add to extraPromptGuidance if empty
                        if (!elements.extraPromptGuidance.value.trim()) {
                            elements.extraPromptGuidance.value = referenceInstructions;
                        }
                    }
                    
                    // Parse each prompt object
                    prompts = jsonData.prompts.map((item, index) => {
                        let promptParts = [];
                        
                        // Add title if available
                        if (item.title) {
                            promptParts.push(item.title);
                        }
                        
                        // Combine pose, outfit, and setting with proper formatting
                        // Pose comes first without label (matching markdown format)
                        if (item.pose) promptParts.push(item.pose);
                        if (item.outfit) promptParts.push(`Outfit: ${item.outfit}`);
                        if (item.setting) promptParts.push(`Setting: ${item.setting}`);
                        
                        // Include any other text fields that might exist
                        const knownFields = ['id', 'title', 'pose', 'outfit', 'setting'];
                        Object.keys(item).forEach(key => {
                            if (!knownFields.includes(key) && typeof item[key] === 'string' && item[key].trim()) {
                                promptParts.push(item[key]);
                            }
                        });
                        
                        // Combine all parts with spaces (not periods) for API compatibility
                        let fullPrompt = promptParts.join(' ');
                        
                        // Prepend reference instructions if provided (only once, not duplicated)
                        if (referenceInstructions && !fullPrompt.includes(referenceInstructions)) {
                            fullPrompt = `${referenceInstructions} ${fullPrompt}`;
                        }
                        
                        return fullPrompt;
                    }).filter(p => p.length > 0);
                    
                    if (prompts.length > 0) {
                        state.prompts = prompts.map((prompt, index) => ({
                            id: index,
                            text: prompt,
                            status: 'pending',
                            result: null,
                            error: null
                        }));
                        
                        renderPromptList();
                        elements.promptList.style.display = 'block';
                        return;
                    }
                }
            } catch (e) {
                // Not JSON, continue with other parsing methods
            }
            
            // Method 1: Check for markdown format with ## PROMPT X: sections
            // First, extract Core Reference Instructions if present
            const coreInstructionsMatch = text.match(/##\s*Core\s+Reference\s+Instructions[\s\S]*?(?=---|##\s*PROMPT|\d+\.|$)/i);
            if (coreInstructionsMatch) {
                const coreInstructions = coreInstructionsMatch[0]
                    .replace(/##\s*Core\s+Reference\s+Instructions[^\n]*\n?/i, '')
                    .replace(/^[\*\-\s]+/gm, '') // Remove markdown list markers
                    .replace(/\n+/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
                
                if (coreInstructions && !elements.extraPromptGuidance.value.trim()) {
                    elements.extraPromptGuidance.value = coreInstructions;
                }
            }
            
            // Initialize prompts array
            prompts = [];
            
            // Method 1: Check for markdown format with ## PROMPT X: sections
            // Split the text by ## PROMPT markers to get individual prompt sections
            const promptSections = text.split(/(?=##\s*PROMPT\s+\d+:)/i);
            
            if (promptSections.length > 1) {
                // Filter out the first section if it's not a prompt (e.g., Core Reference Instructions)
                prompts = promptSections
                    .filter(section => /^##\s*PROMPT\s+\d+:/i.test(section))
                    .map(section => {
                        // Extract everything after the ## PROMPT X: header
                        let content = section.replace(/^##\s*PROMPT\s+\d+:[^\n]*\n?/i, '');
                        
                        // Remove everything from the first "---" separator line onwards
                        // Handle various separator formats: \n---\n, \n---, ---\n, or just ---
                        const separatorPatterns = [
                            /\n---\n/,      // Newline before and after
                            /\n---\s*\n/,  // Newline before, optional whitespace, newline after
                            /\n---\s*$/,   // Newline before, at end of string
                            /^---\s*\n/,   // At start, newline after
                            /^---\s*$/m    // On its own line
                        ];
                        
                        for (const pattern of separatorPatterns) {
                            const match = content.match(pattern);
                            if (match) {
                                const index = content.indexOf(match[0]);
                                content = content.substring(0, index);
                                break;
                            }
                        }
                        
                        // Clean up whitespace
                        content = content
                            .replace(/\n\s*\n+/g, ' ') // Double+ newlines to single space
                            .replace(/\n/g, ' ') // Single newlines to space
                            .replace(/\s+/g, ' ') // Multiple spaces to single
                            .trim();
                        
                        return content;
                    })
                    .filter(p => {
                        // Filter out empty prompts and separator-only content
                        return p.length > 0 && !p.match(/^---\s*$/);
                    });
            }
            
            // Method 2: If markdown didn't work, check for numbered prompts (1., 2., 3., etc.)
            if (prompts.length === 0) {
                // Split by numbered sections to ensure we capture complete prompts
                const numberedSections = text.split(/(?=\d+\.\s+)/);
                
                if (numberedSections.length > 1) {
                    prompts = numberedSections
                        .filter(section => /^\d+\.\s+/.test(section))
                        .map(section => {
                            // Remove the number prefix
                            let content = section.replace(/^\d+\.\s+/, '');
                            
                            // Remove separator lines
                            content = content.replace(/^---\s*$/gm, '');
                            
                            // Clean up whitespace
                            content = content
                                .replace(/\n\s*\n+/g, ' ') // Double+ newlines to single space
                                .replace(/\n/g, ' ') // Single newlines to space
                                .replace(/\s+/g, ' ') // Multiple spaces to single
                                .trim();
                            
                            return content;
                        })
                        .filter(p => {
                            // Filter out empty prompts and lines that are ONLY "---" separators
                            return p.length > 0 && !p.match(/^---\s*$/);
                        });
                }
                
                // If split method didn't work, try regex fallback
                if (prompts.length === 0) {
            const numberedMatches = text.match(/\d+\.\s+[^\n]*(?:\n(?!\d+\.\s)[^\n]*)*/g);
            if (numberedMatches && numberedMatches.length > 0) {
                prompts = numberedMatches.map(match => {
                    const fullPrompt = match
                                .replace(/^\d+\.\s+/, '')
                                .replace(/\n+/g, ' ')
                                .replace(/\s+/g, ' ')
                        .trim();
                    return fullPrompt;
                }).filter(p => {
                    return p.length > 0 && !p.match(/^---\s*$/);
                });
                    }
                }
            }
            
            // Method 3: If still no prompts, try splitting by double newlines
            if (prompts.length === 0) {
                if (text.includes('\n\n')) {
                    prompts = text
                        .split(/\n\n+/)
                        .map(p => p.trim().replace(/\n/g, ' ')) // Replace single newlines with spaces
                        .filter(p => {
                            // Filter out empty prompts and lines that are ONLY "---" separators
                            return p.length > 0 && !p.match(/^---\s*$/);
                        });
                } else {
                    // Method 4: Split by single newlines (one per line)
                    prompts = text
                        .split(/\n+/)
                        .map(p => p.trim())
                        .filter(p => {
                            // Filter out empty prompts and lines that are ONLY "---" separators
                            return p.length > 0 && !p.match(/^---\s*$/);
                        });
                }
            }

            if (prompts.length === 0) {
                alert('No valid prompts found');
                return;
            }

            // Apply AI enhancement if enabled
            const enableEnhancement = document.getElementById('enableEnhancement').checked;
            const preventAIStareEnabled = document.getElementById('preventAIStare').checked;
            
            if (enableEnhancement || preventAIStareEnabled) {
                const enhancementOptions = {
                    injectBodyShape: enableEnhancement && document.getElementById('enhanceBodyShape').checked,
                    injectRealism: enableEnhancement && document.getElementById('enhanceRealism').checked,
                    injectCameraAngle: enableEnhancement && document.getElementById('enhanceCameraAngle').checked,
                    injectLuxury: enableEnhancement && document.getElementById('enhanceLuxury').checked,
                    injectDating: enableEnhancement && document.getElementById('enhanceDating').checked,
                    preventAIStare: preventAIStareEnabled // Always apply if enabled, regardless of other enhancements
                };
                
                prompts = prompts.map(prompt => enhancePrompt(prompt, enhancementOptions));
            }

            state.prompts = prompts.map((prompt, index) => ({
                id: index,
                text: prompt,
                status: 'pending',
                result: null,
                error: null
            }));

            renderPromptList();
            elements.promptList.style.display = 'block';
        });

        elements.clearBtn.addEventListener('click', () => {
            elements.promptsInput.value = '';
            state.prompts = [];
            state.results = [];
            state.uploadedImages = [];
            elements.promptList.style.display = 'none';
            elements.progressSection.style.display = 'none';
            elements.resultsSection.style.display = 'none';
            renderPromptList();
            renderImagePreviews();
            // Note: We don't clear extraPromptGuidance on clear, as it's a master setting
        });

        elements.stopBtn.addEventListener('click', () => {
            state.shouldStop = true;
            state.isProcessing = false;
            elements.stopBtn.disabled = true;
        });

        elements.downloadAllBtn.addEventListener('click', async () => {
            const successfulResults = state.results.filter(r => r.imageUrl);
            if (successfulResults.length === 0) {
                alert('No images to download');
                return;
            }

            // Download with delay between each to avoid browser blocking
            for (let i = 0; i < successfulResults.length; i++) {
                const result = successfulResults[i];
                const index = state.results.indexOf(result);
                
                try {
                    // Fetch the image blob
                    const response = await fetch(result.imageUrl);
                    const blob = await response.blob();
                    
                    let finalBlob = blob;
                    const prompt = result.prompt || '';
                    
                    // Determine image type and add appropriate metadata
                    if (blob.type === 'image/png' || result.imageUrl.includes('.png')) {
                        finalBlob = await addPNGMetadata(blob, prompt);
                    } else if (blob.type === 'image/jpeg' || blob.type === 'image/jpg' || result.imageUrl.includes('.jpg') || result.imageUrl.includes('.jpeg')) {
                        finalBlob = await addJPEGMetadata(blob, prompt);
                    } else {
                        // Try PNG metadata for unknown types
                        finalBlob = await addPNGMetadata(blob, prompt);
                    }
                    
                    // Create download link
                    const url = URL.createObjectURL(finalBlob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `batch-image-${i + 1}.${blob.type.includes('jpeg') ? 'jpg' : 'png'}`;
                    link.click();
                    
                    // Clean up
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                    
                    // Delay between downloads to avoid browser blocking
                    if (i < successfulResults.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                } catch (error) {
                    console.error(`Error downloading image ${i + 1}:`, error);
                    // Fallback to simple download
                    const link = document.createElement('a');
                    link.href = result.imageUrl;
                    link.download = `batch-image-${i + 1}.png`;
                    link.click();
                }
            }
        });

        function renderPromptList() {
            elements.promptList.innerHTML = state.prompts.map((prompt, index) => {
                const statusClass = `status-${prompt.status}`;
                const canDelete = prompt.status === 'pending' && !state.isProcessing;
                return `
                    <div class="prompt-item ${prompt.status}">
                        <div class="prompt-text">${escapeHtml(prompt.text)}</div>
                        <div class="prompt-item-actions">
                            <div class="prompt-status ${statusClass}">
                                ${prompt.status === 'pending' ? '‚è≥ Pending' : 
                                  prompt.status === 'processing' ? '<span class="loading"></span> Processing' :
                                  prompt.status === 'success' ? '‚úì Success' :
                                  prompt.status === 'error' ? '‚úó Error' : ''}
                            </div>
                            ${canDelete ? `<button class="delete-prompt-btn" onclick="deletePrompt(${index})" title="Delete prompt">√ó</button>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            if (state.prompts.length > 0) {
                elements.progressSection.style.display = 'block';
                updateProgress();
            }
        }

        function deletePrompt(index) {
            if (state.isProcessing) {
                alert('Cannot delete prompts while generation is in progress');
                return;
            }
            state.prompts.splice(index, 1);
            // Re-index prompts
            state.prompts = state.prompts.map((p, i) => ({ ...p, id: i }));
            renderPromptList();
        }

        // Make deletePrompt available globally
        window.deletePrompt = deletePrompt;

        function updateProgress() {
            const total = state.prompts.length;
            const completed = state.results.filter(r => r.success).length;
            const failed = state.results.filter(r => !r.success).length;

            elements.totalCount.textContent = total;
            elements.completedCount.textContent = completed;
            elements.failedCount.textContent = failed;

            const progress = total > 0 ? ((completed + failed) / total) * 100 : 0;
            elements.progressFill.style.width = `${progress}%`;
        }

        async function startGeneration() {
            const selectedModel = elements.modelSelect.value;
            
            if (selectedModel === 'seedream-4') {
                if (!elements.seedreamApiKey.value.trim()) {
                    alert('Please enter your Freepik API key');
                    return;
                }
            } else {
                if (!elements.apiKey.value.trim()) {
                    alert('Please enter your Gemini API key');
                    return;
                }
            }

            if (state.prompts.length === 0) {
                alert('Please parse prompts first');
                return;
            }

            state.isProcessing = true;
            state.shouldStop = false;
            state.currentIndex = 0;
            state.results = [];
            elements.stopBtn.disabled = false;
            elements.resultsSection.style.display = 'block';
            elements.resultsGrid.innerHTML = '';

            for (let i = 0; i < state.prompts.length; i++) {
                if (state.shouldStop) {
                    break;
                }

                state.currentIndex = i;
                const prompt = state.prompts[i];
                prompt.status = 'processing';
                renderPromptList();

                try {
                    // Check if using shared API key
                    const useSharedKey = elements.modelSelect.value !== 'seedream-4' && 
                        document.getElementById('useSharedGeminiKey')?.checked && 
                        sharedKeysAvailable.gemini;
                    
                    const apiKey = elements.modelSelect.value === 'seedream-4' 
                        ? elements.seedreamApiKey.value 
                        : (useSharedKey ? 'SHARED_KEY' : elements.apiKey.value);
                    
                    // Validate API key (unless using shared key)
                    if (!useSharedKey && !apiKey) {
                        throw new Error('Please enter your API key or enable shared API key');
                    }
                    
                    // Append extra prompt guidance if provided
                    let finalPrompt = prompt.text;
                    const extraGuidance = elements.extraPromptGuidance.value.trim();
                    if (extraGuidance) {
                        finalPrompt = `${finalPrompt} ${extraGuidance}`;
                    }
                    
                    const imageUrl = await generateImage(
                        apiKey,
                        finalPrompt,
                        parseInt(elements.width.value),
                        parseInt(elements.height.value),
                        state.uploadedImages
                    );

                    prompt.status = 'success';
                    prompt.result = imageUrl;

                    state.results.push({
                        prompt: finalPrompt, // Store the full prompt with extra guidance
                        originalPrompt: prompt.text, // Store original for reference
                        imageUrl: imageUrl,
                        success: true
                    });

                    renderResult(finalPrompt, imageUrl, state.results.length - 1);
                    
                    // Add to history
                    await addToHistory(imageUrl, finalPrompt, {
                        width: parseInt(elements.width.value),
                        height: parseInt(elements.height.value)
                    });
                } catch (error) {
                    prompt.status = 'error';
                    prompt.error = error.message;

                    // Append extra prompt guidance to error display too
                    let errorPrompt = prompt.text;
                    const extraGuidance = elements.extraPromptGuidance.value.trim();
                    if (extraGuidance) {
                        errorPrompt = `${errorPrompt} ${extraGuidance}`;
                    }
                    
                    state.results.push({
                        prompt: errorPrompt,
                        error: error.message,
                        success: false
                    });

                    renderError(errorPrompt, error.message, state.results.length - 1);
                }

                renderPromptList();
                updateProgress();

                // Small delay between requests to avoid rate limiting
                if (i < state.prompts.length - 1 && !state.shouldStop) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }

            state.isProcessing = false;
            elements.stopBtn.disabled = true;
        }

        // Generate ultra-realistic skin, lighting, and camera realism enhancement
        function getRealisticEnhancement() {
            return `

ULTRA-REALISTIC SKIN & LIGHTING REQUIREMENTS (CRITICAL):

SKIN REALISM (FOCUS):
- Visible pores and fine micro-texture throughout the skin
- Natural acne marks, blemishes, and imperfections with organic variation (not patterned or symmetrical)
- Uneven pigmentation and subtle redness in natural areas (cheeks, nose, around mouth)
- Natural oil sheen ONLY on high points (cheekbones, nose bridge, forehead), matte elsewhere
- NO symmetry correction - natural facial asymmetry preserved
- Skin must look healthy and alive, not dull, not glossy
- Luminous quality must come from real light only, not digital effects
- NO retouching, NO smoothing, NO beauty filters
- Natural imperfections must be preserved (freckles, moles, fine lines, texture variations)

COLOR & LIGHT (IMPORTANT):
- Real daylight with slight warmth, natural color temperature
- Natural contrast appropriate to the scene
- Accurate white balance - colors must be true-to-life
- True-to-life colors: skin tones rich and dimensional, fabrics clearly defined, objects have natural color depth
- Colors must be natural and authentic to the scene, not artificially enhanced or muted

CAMERA BEHAVIOR:
- Phone-camera realism: slight edge softness, natural focus falloff
- Subtle sensor grain appropriate to the lighting conditions
- Natural depth of field where appropriate
- No artificial sharpening or over-processing

OVERALL AESTHETIC:
- Modern, clean, minimal, intimate, non-commercial feel
- Editorial-documentary aesthetic
- Must feel like a real person, real skin, real moment
- Authentic and unposed quality

STRICT NEGATIVES (AVOID):
- Faded colors, pastel tones, beige aesthetic
- Flat lighting, overexposed whites, harsh shadows
- AI glow, plastic skin, skincare-ad look
- Studio lighting, artificial lighting setups
- Cartoon style, 3D render style, illustration style
- Text, logos, watermarks
- Over-smoothing, airbrushing, digital retouching effects
- Unnatural symmetry, perfect skin, flawless appearance`;
        }

        async function generateImage(apiKey, prompt, width, height, uploadedImages = []) {
            const model = elements.modelSelect.value;
            
            // Check if using shared API key (apiKey can be empty/placeholder in this case)
            const useSharedKey = document.getElementById('useSharedGeminiKey')?.checked && sharedKeysAvailable.gemini;
            if (useSharedKey) {
                console.log('Using shared API key via proxy');
                console.log('Using shared API key via proxy');
                console.log('Using shared API key via proxy');
                console.log('Using shared API key via proxy');
                console.log('Using shared API key via proxy');
                console.log('Using shared API key via proxy');
                console.log('Using shared API key via proxy');
                // Use placeholder - actual key is in Netlify env vars
                apiKey = 'SHARED_KEY';
            }
            
            // Handle Seedream 4 API (async task-based)
            if (model === 'seedream-4') {
                return await generateSeedreamImage(apiKey, prompt, width, height, uploadedImages);
            }
            
            // Handle Gemini API (synchronous)
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;

            // Build the prompt text
            let promptText = prompt;
            
            // Add ultra-realistic skin and lighting enhancement (optional, controlled by toggle)
            const realismCheckbox = document.getElementById('enableRealismEnhancement');
            const enableRealismEnhancement = !realismCheckbox || realismCheckbox.checked; // Default to true if checkbox doesn't exist
            if (enableRealismEnhancement) {
            promptText += getRealisticEnhancement();
            }
            
            // If reference images are provided, add instructions to use them for likeness only
            if (uploadedImages && uploadedImages.length > 0) {
                const imageInstruction = `\n\nIMPORTANT: The uploaded reference image(s) are provided for subject likeness, appearance, facial features, and styling reference ONLY. DO NOT copy the pose, position, body arrangement, camera angle, or action from the reference images. Instead, follow the pose, position, action, and composition described in the prompt text above. Use the reference images solely to maintain consistent subject appearance and features across different poses and scenarios.`;
                promptText = promptText + imageInstruction;
            }
            
            promptText += `\n\nOutput dimensions: ${width}x${height}`;

            const contents = [{
                role: "user",
                parts: [{ text: promptText }]
            }];

            // Add uploaded images to the request
            if (uploadedImages && uploadedImages.length > 0) {
                uploadedImages.forEach(img => {
                    contents[0].parts.push({
                        inline_data: {
                            mime_type: img.mimeType || "image/png",
                            data: img.base64
                        }
                    });
                });
            }

            const requestBody = {
                contents: contents,
                generationConfig: {
                    temperature: 1,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 8192,
                }
            };

            let response;
            if (useSharedKey) {
                console.log('Using shared API key via proxy');
                console.log('Using shared API key via proxy');
                console.log('Using shared API key via proxy');
                console.log('Using shared API key via proxy');
                console.log('Using shared API key via proxy');
                console.log('Using shared API key via proxy');
                console.log('Using shared API key via proxy');
                // Use Netlify function proxy to keep API key secure
                response = await fetch('/.netlify/functions/gemini-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: model,
                        contents: contents,
                        generationConfig: requestBody.generationConfig
                    })
                });
            } else {
                // Use direct API call with user's API key
                response = await fetch(`${url}?key=${apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody)
            });
            }

            if (!response.ok) {
                const errorText = await response.text();
                let errorData;
                try {
                    errorData = JSON.parse(errorText);
                } catch (e) {
                    errorData = { error: { message: errorText } };
                }
                console.error('API Error:', errorData);
                throw new Error(errorData.error?.message || errorData.error || `HTTP ${response.status}: ${response.statusText}`);
            }

            const responseText = await response.text();
            let data;
            try {
                data = JSON.parse(responseText);
            } catch (e) {
                console.error('Failed to parse response:', responseText);
                throw new Error('Invalid JSON response from API');
            }
            
            console.log('API Response:', data);

            // Extract image from response
            const candidate = data.candidates?.[0];
            if (!candidate || !candidate.content || !candidate.content.parts) {
                throw new Error('No image generated in response');
            }

            const part = candidate.content.parts.find(p => p.inlineData);
            if (!part || !part.inlineData) {
                throw new Error('No image data found in response');
            }

            // Convert base64 to blob URL
            const base64Data = part.inlineData.data;
            const mimeType = part.inlineData.mimeType || 'image/png';
            const blob = base64ToBlob(base64Data, mimeType);
            return URL.createObjectURL(blob);
        }

        async function generateSeedreamImage(apiKey, prompt, width, height, uploadedImages = []) {
            // Step 1: Create generation task
            const createTaskUrl = 'https://api.freepik.com/v1/ai/text-to-image/seedream-v4';
            
            // Build prompt text
            let promptText = prompt;
            
            // Add ultra-realistic skin and lighting enhancement (optional, controlled by toggle)
            const realismCheckbox = document.getElementById('enableRealismEnhancement');
            const enableRealismEnhancement = !realismCheckbox || realismCheckbox.checked; // Default to true if checkbox doesn't exist
            if (enableRealismEnhancement) {
            promptText += getRealisticEnhancement();
            }
            
            if (uploadedImages && uploadedImages.length > 0) {
                promptText += ` [Reference images provided for style/character guidance]`;
            }
            
            const requestBody = {
                prompt: promptText,
                width: width,
                height: height,
                // Note: Seedream 4 may not support image inputs directly in text-to-image endpoint
                // You may need to use image-to-image endpoint for reference images
            };

            // Create task
            const createResponse = await fetch(createTaskUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'x-freepik-api-key': apiKey
                },
                body: JSON.stringify(requestBody)
            });

            if (!createResponse.ok) {
                const errorData = await createResponse.json().catch(() => ({}));
                throw new Error(errorData.message || errorData.error || `HTTP ${createResponse.status}: ${createResponse.statusText}`);
            }

            const taskData = await createResponse.json();
            const taskId = taskData.data?.id || taskData.id || taskData.task_id;

            if (!taskId) {
                throw new Error('No task ID returned from Seedream API');
            }

            // Step 2: Poll for task completion
            const statusUrl = `https://api.freepik.com/v1/ai/text-to-image/seedream-v4/${taskId}`;
            const maxAttempts = 60; // 5 minutes max (5 second intervals)
            let attempts = 0;

            while (attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds

                const statusResponse = await fetch(statusUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'x-freepik-api-key': apiKey
                    }
                });

                if (!statusResponse.ok) {
                    const errorData = await statusResponse.json().catch(() => ({}));
                    throw new Error(errorData.message || errorData.error || `HTTP ${statusResponse.status}: ${statusResponse.statusText}`);
                }

                const statusData = await statusResponse.json();
                const status = statusData.data?.status || statusData.status;

                if (status === 'completed' || status === 'success') {
                    // Step 3: Get the image URL
                    const imageUrl = statusData.data?.image_url || statusData.data?.url || statusData.image_url || statusData.url;
                    
                    if (!imageUrl) {
                        throw new Error('No image URL in completed task response');
                    }

                    // Fetch the image and convert to blob URL
                    const imageResponse = await fetch(imageUrl);
                    if (!imageResponse.ok) {
                        throw new Error(`Failed to fetch generated image: ${imageResponse.statusText}`);
                    }
                    
                    const blob = await imageResponse.blob();
                    return URL.createObjectURL(blob);
                } else if (status === 'failed' || status === 'error') {
                    const errorMsg = statusData.data?.error || statusData.error || 'Task failed';
                    throw new Error(`Seedream generation failed: ${errorMsg}`);
                } else if (status === 'processing' || status === 'pending' || status === 'in_progress') {
                    // Continue polling
                    attempts++;
                    continue;
                } else {
                    throw new Error(`Unknown task status: ${status}`);
                }
            }

            throw new Error('Seedream generation timed out after 5 minutes');
        }

        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        }

        function renderResult(prompt, imageUrl, index) {
            const card = document.createElement('div');
            card.className = 'result-card';
            
            // Check if prompt is long enough to need collapse/expand
            const promptLength = prompt.length;
            const needsCollapse = promptLength > 200;
            const promptId = `prompt-${index}`;
            
            card.innerHTML = `
                <img src="${imageUrl}" alt="Generated" class="result-image" />
                <div class="result-info">
                    <div style="margin-bottom: 10px;">
                        <div style="font-size: 10px; color: #999; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Full Prompt:</div>
                        <div id="${promptId}" class="result-prompt ${needsCollapse ? 'collapsed' : ''}">${escapeHtml(prompt)}</div>
                        ${needsCollapse ? `<button class="expand-prompt-btn" onclick="togglePrompt('${promptId}')">Show More</button>` : ''}
                    </div>
                    <div class="result-actions">
                        <button class="btn btn-small" onclick="downloadImage('${imageUrl}', ${index})">Download</button>
                        <button class="btn btn-small btn-secondary" onclick="copyPromptFromResult(${index})">Copy Prompt</button>
                    </div>
                </div>
            `;
            elements.resultsGrid.appendChild(card);
        }

        function togglePrompt(promptId) {
            const promptEl = document.getElementById(promptId);
            const btn = promptEl.nextElementSibling;
            
            if (promptEl.classList.contains('collapsed')) {
                promptEl.classList.remove('collapsed');
                btn.textContent = 'Show Less';
            } else {
                promptEl.classList.add('collapsed');
                btn.textContent = 'Show More';
            }
        }

        // Make togglePrompt available globally
        window.togglePrompt = togglePrompt;

        function renderError(prompt, error, index) {
            const card = document.createElement('div');
            card.className = 'result-card';
            
            // Check if prompt is long enough to need collapse/expand
            const promptLength = prompt.length;
            const needsCollapse = promptLength > 200;
            const promptId = `prompt-error-${index}`;
            
            card.innerHTML = `
                <div style="padding: 40px; text-align: center; color: #dc3545;">
                    <div style="font-size: 48px; margin-bottom: 10px;">‚úó</div>
                    <div style="font-weight: 600; margin-bottom: 5px;">Generation Failed</div>
                    <div style="font-size: 12px; color: #666;">${escapeHtml(error)}</div>
                </div>
                <div class="result-info">
                    <div style="margin-bottom: 10px;">
                        <div style="font-size: 10px; color: #999; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">Full Prompt:</div>
                        <div id="${promptId}" class="result-prompt ${needsCollapse ? 'collapsed' : ''}">${escapeHtml(prompt)}</div>
                        ${needsCollapse ? `<button class="expand-prompt-btn" onclick="togglePrompt('${promptId}')">Show More</button>` : ''}
                    </div>
                    <div class="result-actions">
                        <button class="btn btn-small btn-secondary" onclick="copyPromptFromResult(${index})">Copy Prompt</button>
                    </div>
                </div>
            `;
            elements.resultsGrid.appendChild(card);
        }

        // Add PNG text chunk (tEXt) with prompt metadata
        async function addPNGMetadata(imageBlob, prompt) {
            const arrayBuffer = await imageBlob.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            // PNG signature: 89 50 4E 47 0D 0A 1A 0A
            if (uint8Array[0] !== 0x89 || uint8Array[1] !== 0x50 || 
                uint8Array[2] !== 0x4E || uint8Array[3] !== 0x47) {
                return imageBlob; // Not a PNG, return as-is
            }
            
            // Find IEND chunk (last chunk)
            let iendPos = -1;
            for (let i = uint8Array.length - 12; i >= 0; i--) {
                if (uint8Array[i] === 0x49 && uint8Array[i+1] === 0x45 && 
                    uint8Array[i+2] === 0x4E && uint8Array[i+3] === 0x44) {
                    iendPos = i - 4; // Position before length field
                    break;
                }
            }
            
            if (iendPos === -1) return imageBlob; // Couldn't find IEND
            
            // Create tEXt chunk: keyword "Prompt" + null byte + text
            const keyword = 'Prompt';
            const text = prompt;
            const keywordBytes = new TextEncoder().encode(keyword);
            const textBytes = new TextEncoder().encode(text);
            
            // tEXt chunk structure: [length (4 bytes)] [type: tEXt (4 bytes)] [keyword + \0 + text] [CRC (4 bytes)]
            const chunkDataLength = keywordBytes.length + 1 + textBytes.length;
            const chunkLength = 4 + 4 + chunkDataLength + 4; // length + type + data + CRC
            
            // Create new array with tEXt chunk inserted before IEND
            const newArray = new Uint8Array(uint8Array.length + chunkLength);
            newArray.set(uint8Array.slice(0, iendPos), 0);
            
            // Write chunk length (big-endian)
            const view = new DataView(newArray.buffer, iendPos);
            view.setUint32(iendPos, chunkDataLength, false);
            
            // Write chunk type "tEXt"
            newArray[iendPos + 4] = 0x74; // t
            newArray[iendPos + 5] = 0x45; // E
            newArray[iendPos + 6] = 0x58; // X
            newArray[iendPos + 7] = 0x74; // t
            
            // Write keyword + null + text
            let pos = iendPos + 8;
            newArray.set(keywordBytes, pos);
            pos += keywordBytes.length;
            newArray[pos++] = 0; // Null separator
            newArray.set(textBytes, pos);
            pos += textBytes.length;
            
            // Calculate CRC (simplified - using a basic CRC32)
            const crcStart = iendPos + 4;
            const crcEnd = pos;
            let crc = 0xFFFFFFFF;
            for (let i = crcStart; i < crcEnd; i++) {
                crc ^= newArray[i];
                for (let j = 0; j < 8; j++) {
                    crc = (crc >>> 1) ^ (crc & 1 ? 0xEDB88320 : 0);
                }
            }
            crc = (crc ^ 0xFFFFFFFF) >>> 0;
            view.setUint32(pos, crc, false);
            pos += 4;
            
            // Copy IEND chunk
            newArray.set(uint8Array.slice(iendPos), pos);
            
            return new Blob([newArray], { type: 'image/png' });
        }
        
        // Add JPEG EXIF metadata with prompt
        async function addJPEGMetadata(imageBlob, prompt) {
            try {
                const arrayBuffer = await imageBlob.arrayBuffer();
                const binaryString = Array.from(new Uint8Array(arrayBuffer))
                    .map(byte => String.fromCharCode(byte))
                    .join('');
                
                // Get existing EXIF data or create new
                let exifObj = {};
                try {
                    exifObj = piexif.load(binaryString);
                } catch (e) {
                    // No existing EXIF, create new
                    exifObj = { "0th": {}, "Exif": {}, "GPS": {}, "Interop": {}, "1st": {}, "thumbnail": null };
                }
                
                // Add prompt to UserComment in EXIF
                const userComment = JSON.stringify({ prompt: prompt });
                exifObj.Exif[piexif.ExifIFD.UserComment] = userComment;
                
                // Also add to ImageDescription for easier access
                exifObj["0th"][piexif.ImageIFD.ImageDescription] = `AI Generated Image - Prompt: ${prompt.substring(0, 200)}`;
                
                // Insert EXIF data
                const exifStr = piexif.dump(exifObj);
                const newBinaryString = piexif.insert(exifStr, binaryString);
                
                // Convert back to blob
                const newArray = new Uint8Array(newBinaryString.length);
                for (let i = 0; i < newBinaryString.length; i++) {
                    newArray[i] = newBinaryString.charCodeAt(i);
                }
                
                return new Blob([newArray], { type: 'image/jpeg' });
            } catch (error) {
                console.error('Error adding JPEG metadata:', error);
                return imageBlob; // Return original if metadata addition fails
            }
        }
        
        // Make downloadImage available globally
        window.downloadImage = async function(imageUrl, index) {
            try {
                const result = state.results[index];
                if (!result || !result.prompt) {
                    // Fallback to simple download
                    const link = document.createElement('a');
                    link.href = imageUrl;
                    link.download = `batch-image-${index + 1}.png`;
                    link.click();
                    return;
                }
                
                // Fetch the image blob
                const response = await fetch(imageUrl);
                const blob = await response.blob();
                
                let finalBlob = blob;
                const prompt = result.prompt;
                
                // Determine image type and add appropriate metadata
                if (blob.type === 'image/png' || imageUrl.includes('.png')) {
                    finalBlob = await addPNGMetadata(blob, prompt);
                } else if (blob.type === 'image/jpeg' || blob.type === 'image/jpg' || imageUrl.includes('.jpg') || imageUrl.includes('.jpeg')) {
                    finalBlob = await addJPEGMetadata(blob, prompt);
                } else {
                    // Try PNG metadata for unknown types
                    finalBlob = await addPNGMetadata(blob, prompt);
                }
                
                // Create download link
                const url = URL.createObjectURL(finalBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `batch-image-${index + 1}.${blob.type.includes('jpeg') ? 'jpg' : 'png'}`;
                link.click();
                
                // Clean up
                setTimeout(() => URL.revokeObjectURL(url), 100);
            } catch (error) {
                console.error('Error downloading image with metadata:', error);
                // Fallback to simple download
                const link = document.createElement('a');
                link.href = imageUrl;
                link.download = `batch-image-${index + 1}.png`;
                link.click();
            }
        };

        function copyPrompt(prompt) {
            // Unescape the prompt text before copying
            const unescapedPrompt = prompt.replace(/\\'/g, "'").replace(/\\"/g, '"');
            navigator.clipboard.writeText(unescapedPrompt).then(() => {
                alert('Prompt copied to clipboard!');
            });
        }

        function copyPromptFromResult(index) {
            const result = state.results[index];
            if (result && result.prompt) {
                navigator.clipboard.writeText(result.prompt).then(() => {
                    alert('Prompt copied to clipboard!');
                });
            }
        }

        // Make copyPromptFromResult available globally
        window.copyPromptFromResult = copyPromptFromResult;

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============================================
        // History Management
        // ============================================

        // Convert blob URL to base64
        async function blobUrlToBase64(blobUrl) {
            try {
                const response = await fetch(blobUrl);
                const blob = await response.blob();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const base64 = reader.result.split(',')[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error('Error converting blob URL to base64:', error);
                return null;
            }
        }

        // Load history from localStorage
        function loadHistory() {
            const stored = localStorage.getItem('batch-generator-history');
            if (stored) {
                try {
                    state.history = JSON.parse(stored);
                } catch (e) {
                    state.history = [];
                }
            }
            renderHistory();
        }

        // Compress image for history storage (reduce quality and size)
        function compressImageForHistory(base64, maxWidth = 800, quality = 0.7) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
                    
                    // Calculate new dimensions
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert to compressed base64
                    const compressedBase64 = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressedBase64);
                };
                img.onerror = () => resolve(base64); // Fallback to original if compression fails
                img.src = base64;
            });
        }

        // Save history to localStorage with error handling and compression
        function saveHistory() {
            // Limit history to prevent quota issues (reduced from 50 to 15)
            const MAX_HISTORY_ITEMS = 15;
            
            // Always keep history trimmed to max items
                if (state.history.length > MAX_HISTORY_ITEMS) {
                // Remove oldest items (keep most recent)
                state.history = state.history.slice(-MAX_HISTORY_ITEMS);
                }
            
            try {
                localStorage.setItem('batch-generator-history', JSON.stringify(state.history));
            } catch (error) {
                if (error.name === 'QuotaExceededError' || error.message.includes('quota')) {
                    // Silently reduce history size progressively
                    let reduced = false;
                    for (let limit of [10, 5, 3, 0]) {
                        if (state.history.length > limit) {
                            state.history = state.history.slice(-limit);
                        try {
                            localStorage.setItem('batch-generator-history', JSON.stringify(state.history));
                                reduced = true;
                                break;
                            } catch (e) {
                                // Continue to next reduction
                            }
                        }
                    }
                    
                    if (!reduced) {
                        // Last resort: clear history
                        state.history = [];
                        try {
                        localStorage.removeItem('batch-generator-history');
                        } catch (e) {
                            // Ignore errors when clearing
                        }
                    }
                } else {
                    console.error('Error saving history:', error);
                }
            }
        }

        // Add item to history
        async function addToHistory(imageUrl, prompt, dimensions) {
            try {
                const imageBase64 = await blobUrlToBase64(imageUrl);
                if (!imageBase64) {
                    console.error('Failed to convert image to base64');
                    return;
                }

                // Compress image for storage to reduce localStorage usage
                const compressedBase64 = await compressImageForHistory(imageBase64);

                const historyItem = {
                    id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                    imageBase64: compressedBase64, // Store compressed version
                    prompt: prompt,
                    dimensions: dimensions,
                    timestamp: new Date().toISOString(),
                    selected: false
                };
                state.history.unshift(historyItem); // Add to beginning
                
                // saveHistory() handles limiting items automatically
                saveHistory();
                renderHistory();
            } catch (error) {
                console.error('Error adding to history:', error);
                // Continue execution even if history fails
            }
        }

        // Render history grid
        function renderHistory() {
            if (state.history.length === 0) {
                elements.historyGrid.innerHTML = '';
                elements.noHistoryMessage.style.display = 'block';
                return;
            }

            elements.noHistoryMessage.style.display = 'none';
            elements.historyGrid.innerHTML = state.history.map(item => {
                const date = new Date(item.timestamp);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                const promptPreview = item.prompt.length > 100 
                    ? item.prompt.substring(0, 100) + '...' 
                    : item.prompt;
                
                return `
                    <div class="history-item ${item.selected ? 'selected' : ''}" data-id="${item.id}">
                        <input type="checkbox" class="history-item-checkbox" ${item.selected ? 'checked' : ''} 
                               onchange="toggleHistoryItem('${item.id}')" />
                        <img src="data:image/png;base64,${item.imageBase64}" alt="Generated" />
                        <div class="history-item-prompt" title="${escapeHtml(item.prompt)}">${escapeHtml(promptPreview)}</div>
                        <div class="history-item-date">${dateStr}</div>
                    </div>
                `;
            }).join('');
        }

        // Toggle history item selection
        window.toggleHistoryItem = function(id) {
            const item = state.history.find(h => h.id === id);
            if (item) {
                item.selected = !item.selected;
                saveHistory();
                renderHistory();
            }
        };

        // Select all history items
        elements.selectAllBtn.addEventListener('click', () => {
            state.history.forEach(item => item.selected = true);
            saveHistory();
            renderHistory();
        });

        // Deselect all history items
        elements.deselectAllBtn.addEventListener('click', () => {
            state.history.forEach(item => item.selected = false);
            saveHistory();
            renderHistory();
        });

        // Clear history
        elements.clearHistoryBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all history? This cannot be undone.')) {
                state.history = [];
                saveHistory();
                renderHistory();
                alert('History cleared successfully!');
            }
        });

        // Export to PDF
        elements.exportPdfBtn.addEventListener('click', async () => {
            const selected = state.history.filter(item => item.selected);
            
            if (selected.length === 0) {
                alert('Please select at least one item to export');
                return;
            }

            elements.exportPdfBtn.disabled = true;
            elements.exportPdfBtn.textContent = '‚è≥ Generating PDF...';

            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });

                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 15;
                const imageWidth = pageWidth - (margin * 2);
                let yPos = margin;

                for (let i = 0; i < selected.length; i++) {
                    const item = selected[i];
                    
                    // Add new page if not first item
                    if (i > 0) {
                        pdf.addPage();
                        yPos = margin;
                    }

                    // Convert base64 to image
                    const img = new Image();
                    img.src = `data:image/png;base64,${item.imageBase64}`;
                    
                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            try {
                                // Calculate image height to fit width
                                const aspectRatio = img.height / img.width;
                                const imageHeight = imageWidth * aspectRatio;
                                
                                // Check if image fits on page
                                if (yPos + imageHeight > pageHeight - margin - 40) {
                                    pdf.addPage();
                                    yPos = margin;
                                }
                                
                                // Add image
                                pdf.addImage(img, 'PNG', margin, yPos, imageWidth, imageHeight);
                                yPos += imageHeight + 10;
                                
                                // Add prompt text
                                const promptLines = pdf.splitTextToSize(item.prompt, imageWidth);
                                const promptHeight = promptLines.length * 5;
                                
                                // Check if prompt fits on page
                                if (yPos + promptHeight > pageHeight - margin) {
                                    pdf.addPage();
                                    yPos = margin;
                                }
                                
                                pdf.setFontSize(10);
                                pdf.text('Prompt:', margin, yPos);
                                yPos += 5;
                                pdf.setFontSize(8);
                                pdf.text(promptLines, margin, yPos);
                                yPos += promptHeight + 10;
                                
                                resolve();
                            } catch (err) {
                                reject(err);
                            }
                        };
                        img.onerror = () => {
                            reject(new Error(`Failed to load image ${i + 1}`));
                        };
                    });
                }

                pdf.save(`batch-generator-${Date.now()}.pdf`);
                alert(`PDF exported successfully with ${selected.length} item(s)!`);
            } catch (error) {
                console.error('PDF export error:', error);
                alert(`Error exporting PDF: ${error.message}`);
            } finally {
                elements.exportPdfBtn.disabled = false;
                elements.exportPdfBtn.textContent = 'üìÑ Export PDF';
            }
        });

        // Export to ZIP
        elements.exportZipBtn.addEventListener('click', async () => {
            const selected = state.history.filter(item => item.selected);
            
            if (selected.length === 0) {
                alert('Please select at least one item to export');
                return;
            }

            elements.exportZipBtn.disabled = true;
            elements.exportZipBtn.textContent = '‚è≥ Creating ZIP...';

            try {
                const zip = new JSZip();
                const promptsText = [];

                for (let i = 0; i < selected.length; i++) {
                    const item = selected[i];
                    const date = new Date(item.timestamp);
                    const filename = `image-${i + 1}-${date.getTime()}.png`;
                    
                    // Add image to zip
                    const imageData = atob(item.imageBase64);
                    const imageBytes = new Uint8Array(imageData.length);
                    for (let j = 0; j < imageData.length; j++) {
                        imageBytes[j] = imageData.charCodeAt(j);
                    }
                    zip.file(filename, imageBytes);
                    
                    // Add prompt to text array
                    promptsText.push(`--- Image ${i + 1}: ${filename} ---\n${item.prompt}\n`);
                }

                // Add prompts text file
                zip.file('prompts.txt', promptsText.join('\n\n'));

                // Generate and download ZIP
                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `batch-generator-${Date.now()}.zip`;
                a.click();
                URL.revokeObjectURL(url);

                alert(`ZIP exported successfully with ${selected.length} item(s)!`);
            } catch (error) {
                console.error('ZIP export error:', error);
                alert(`Error exporting ZIP: ${error.message}`);
            } finally {
                elements.exportZipBtn.disabled = false;
                elements.exportZipBtn.textContent = 'üì¶ Export ZIP';
            }
        });

        // Initialize history on load
        loadHistory();

        // Add start button after parsing
        elements.parseBtn.addEventListener('click', () => {
            setTimeout(() => {
                if (state.prompts.length > 0 && !document.getElementById('startBtn')) {
                    const startBtn = document.createElement('button');
                    startBtn.id = 'startBtn';
                    startBtn.className = 'btn';
                    startBtn.textContent = 'üöÄ Start Generation';
                    startBtn.style.marginTop = '15px';
                    startBtn.addEventListener('click', startGeneration);
                    elements.parseBtn.parentElement.appendChild(startBtn);
                }
            }, 100);
        });
    </script>
</body>
</html>


