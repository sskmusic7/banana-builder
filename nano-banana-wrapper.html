<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üçå Nano Banana Wrapper - Gemini 2.5 Flash Image Generator</title>
    <style>
        :root {
            --primary: #667eea;
            --primary-dark: #5568d3;
            --secondary: #764ba2;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --info: #17a2b8;
            --bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --shadow: 0 20px 60px rgba(0,0,0,0.3);
            --shadow-hover: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: var(--bg-gradient);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: var(--shadow);
            padding: 40px;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 700;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            border: 1px solid #e9ecef;
        }

        .section-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        input[type="text"],
        input[type="password"],
        textarea,
        select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: all 0.3s;
            font-family: inherit;
            background: white;
        }

        input[type="text"]:focus,
        input[type="password"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .model-select {
            font-weight: 600;
            cursor: pointer;
        }

        .model-select option {
            padding: 10px;
        }

        textarea {
            min-height: 120px;
            resize: vertical;
        }

        select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: all 0.3s;
            font-family: inherit;
            background: white;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .api-key-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .api-key-wrapper input {
            flex: 1;
        }

        .toggle-visibility {
            padding: 12px 15px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s;
        }

        .toggle-visibility:hover {
            background: var(--primary-dark);
        }

        .file-upload-area {
            border: 2px dashed #ddd;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }

        .file-upload-area:hover {
            border-color: var(--primary);
            background: #f8f9ff;
        }

        .file-upload-area.dragover {
            border-color: var(--primary);
            background: #f0f0ff;
        }

        .file-upload-area input[type="file"] {
            display: none;
        }

        .file-upload-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .file-preview {
            margin-top: 15px;
            display: none;
        }

        .file-preview img {
            max-width: 100%;
            max-height: 400px;
            border-radius: 8px;
            border: 2px solid #ddd;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .filename-display {
            margin-top: 10px;
            color: var(--success);
            font-weight: 600;
            font-size: 0.9em;
        }

        .dimension-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-top: 10px;
        }

        .dimension-btn {
            padding: 15px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 0.9em;
            text-align: center;
        }

        .dimension-btn:hover {
            border-color: var(--primary);
            background: #f0f0ff;
            transform: translateY(-2px);
        }

        .dimension-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .rate-limit-card {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border: 2px solid var(--warning);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 25px;
        }

        .rate-limit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .rate-limit-counter {
            font-size: 1.8em;
            font-weight: bold;
            color: #333;
        }

        .rate-limit-counter.warning {
            color: var(--danger);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .progress-bar-container {
            width: 100%;
            height: 24px;
            background: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            margin: 15px 0;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--success) 0%, var(--warning) 70%, var(--danger) 100%);
            transition: width 0.5s ease;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 8px;
            color: white;
            font-weight: 600;
            font-size: 0.85em;
        }

        .rate-limit-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .rate-limit-input {
            width: 100px;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 6px;
            text-align: center;
            font-weight: 600;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
        }

        .btn-primary {
            background: var(--bg-gradient);
            color: white;
            width: 100%;
            padding: 18px;
            font-size: 1.2em;
            margin-top: 20px;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-hover);
        }

        .btn-primary:active:not(:disabled) {
            transform: translateY(0);
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .loading {
            display: none;
            text-align: center;
            margin: 30px 0;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            display: none;
            animation: slideDown 0.3s ease;
            line-height: 1.6;
            word-wrap: break-word;
        }

        .alert a {
            color: inherit;
            text-decoration: underline;
            font-weight: 600;
        }

        .alert.active {
            display: block;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid var(--danger);
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border-left: 4px solid var(--info);
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid var(--success);
        }

        .output-section {
            margin-top: 40px;
            padding-top: 40px;
            border-top: 2px solid #eee;
            display: none;
        }

        .output-section.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .output-image {
            text-align: center;
        }

        .output-image img {
            max-width: 100%;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        .output-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .info-box {
            background: #e7f3ff;
            border-left: 4px solid var(--primary);
            padding: 20px;
            margin-bottom: 25px;
            border-radius: 8px;
        }

        .info-box strong {
            display: block;
            margin-bottom: 10px;
            color: #333;
        }

        .info-box ul {
            margin-left: 20px;
            margin-top: 10px;
        }

        .info-box li {
            margin: 8px 0;
            color: #555;
        }

        .info-box a {
            color: var(--primary);
            text-decoration: none;
            font-weight: 600;
        }

        .info-box a:hover {
            text-decoration: underline;
        }

        .reset-info {
            font-size: 0.9em;
            color: #666;
            margin-top: 10px;
            font-style: italic;
        }

        .prompt-suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .prompt-chip {
            padding: 6px 12px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .prompt-chip:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 2em;
            }

            .dimension-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .rate-limit-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .rate-limit-input {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="/" style="display: inline-block; margin-bottom: 20px; padding: 8px 16px; background: var(--primary); color: white; text-decoration: none; border-radius: 8px; font-weight: 600; transition: transform 0.2s ease;" onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">‚Üê Home</a>
        <header>
            <h1>üçå Nano Banana Wrapper</h1>
            <p class="subtitle">Gemini 2.5 Flash Image Generator - Text + Image to Image</p>
        </header>

        <!-- Rate Limit Section -->
        <div class="rate-limit-card">
            <div class="rate-limit-header">
                <div>
                    <strong>üìä Daily Rate Limit</strong>
                </div>
                <div class="rate-limit-counter" id="rateLimitCounter">0 / 100</div>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar" style="width: 0%"></div>
            </div>
            <div class="rate-limit-controls">
                <label for="dailyLimit">Daily Limit:</label>
                <input type="number" id="dailyLimit" class="rate-limit-input" value="100" min="1" max="10000" />
                <button class="btn btn-danger" id="resetLimitBtn">Reset Counter</button>
            </div>
            <div class="reset-info" id="resetInfo">Resets at midnight (local time)</div>
        </div>

        <!-- Info Box -->
        <div class="info-box">
            <strong>üí° Quick Tips:</strong>
            <ul>
                <li>Get your API key from <a href="https://aistudio.google.com/apikey" target="_blank" rel="noopener noreferrer">Google AI Studio</a></li>
                <li>Upload an image to edit/blend or leave empty to generate from text only</li>
                <li>Text prompt can be natural language or JSON - Gemini understands both</li>
                <li>Use multiple images by uploading one and describing others in the prompt</li>
                <li>Generated images are stored in your browser's localStorage for quick access</li>
            </ul>
        </div>

        <!-- API Key Section -->
        <div class="section">
            <div class="section-title">üîë API Configuration</div>
            <div class="form-group">
                <label for="apiKey">Google AI API Key</label>
                <div class="api-key-wrapper">
                    <input type="password" id="apiKey" placeholder="Enter your Google AI API key" autocomplete="off" />
                    <button type="button" class="toggle-visibility" id="toggleApiKey">üëÅÔ∏è</button>
                </div>
            </div>
        </div>

        <!-- Prompt Section -->
        <div class="section">
            <div class="section-title">‚úçÔ∏è Text Prompt</div>
            <div class="form-group">
                <label for="prompt">Describe what you want to generate (Natural Language or JSON)</label>
                <textarea id="prompt" placeholder="Example: Create a futuristic cityscape at sunset with flying cars and neon lights
Or: Edit this image to make the background more vibrant and add dramatic lighting
Or JSON: {&quot;style&quot;: &quot;cyberpunk&quot;, &quot;elements&quot;: [&quot;neon lights&quot;, &quot;rain&quot;], &quot;mood&quot;: &quot;dark&quot;}"></textarea>
                <div class="prompt-suggestions">
                    <span class="prompt-chip" data-prompt="A serene mountain landscape at sunrise">üåÑ Mountain Sunrise</span>
                    <span class="prompt-chip" data-prompt="A futuristic cyberpunk city with neon lights">üåÉ Cyberpunk City</span>
                    <span class="prompt-chip" data-prompt="A cute cartoon banana with sunglasses">üçå Cool Banana</span>
                    <span class="prompt-chip" data-prompt="Abstract geometric patterns in vibrant colors">üé® Abstract Art</span>
                </div>
            </div>
        </div>

        <!-- Image Upload Section -->
        <div class="section">
            <div class="section-title">üì∑ Image Upload (Optional)</div>
            <div class="form-group">
                <div class="file-upload-area" id="fileUploadArea">
                    <div class="file-upload-icon">üì§</div>
                    <p><strong>Click to upload</strong> or drag and drop</p>
                    <p style="color: #666; font-size: 0.9em; margin-top: 5px;">JPG, PNG, WebP (Max 10MB)</p>
                    <input type="file" id="imageInput" accept="image/*" />
                </div>
                <div class="filename-display" id="filenameDisplay"></div>
                <div class="file-preview" id="filePreview">
                    <img id="previewImage" alt="Preview" />
                </div>
            </div>
        </div>

        <!-- Model Selection Section -->
        <div class="section">
            <div class="section-title">ü§ñ AI Model Selection</div>
            <div class="form-group">
                <label for="modelSelect">Choose Gemini Model</label>
                <select id="modelSelect" class="model-select">
                    <option value="gemini-2.5-flash-image" selected>Gemini 2.5 Flash Image (Recommended - Stable)</option>
                    <option value="gemini-2.5-flash-preview-image">Gemini 2.5 Flash Preview Image (Preview)</option>
                    <option value="gemini-2.0-flash-exp-image-generation">Gemini 2.0 Flash Exp Image (Experimental)</option>
                    <option value="custom">Custom Model (Enter below)</option>
                </select>
                <div id="customModelContainer" style="display: none; margin-top: 10px;">
                    <label for="customModelInput">Custom Model Name:</label>
                    <input type="text" id="customModelInput" placeholder="e.g., gemini-3.0-pro-image" style="margin-top: 5px;" />
                </div>
                <p style="margin-top: 8px; color: #666; font-size: 0.9em;">
                    ‚ö†Ô∏è <strong>Note:</strong> Gemini 3.0 image generation models are not yet available via the API. The models listed above are the currently available options. Check <a href="https://ai.google.dev/gemini-api/docs/models" target="_blank" rel="noopener noreferrer">official documentation</a> for updates on new model releases.
                </p>
            </div>
        </div>

        <!-- Dimensions Section -->
        <div class="section">
            <div class="section-title">üìê Output Dimensions</div>
            <div class="dimension-grid">
                <button class="dimension-btn active" data-width="1024" data-height="1024">1024√ó1024<br><small>Square</small></button>
                <button class="dimension-btn" data-width="1024" data-height="768">1024√ó768<br><small>Landscape</small></button>
                <button class="dimension-btn" data-width="768" data-height="1024">768√ó1024<br><small>Portrait</small></button>
                <button class="dimension-btn" data-width="1536" data-height="1024">1536√ó1024<br><small>Wide</small></button>
                <button class="dimension-btn" data-width="1024" data-height="1536">1024√ó1536<br><small>Tall</small></button>
                <button class="dimension-btn" data-width="2048" data-height="2048">2048√ó2048<br><small>Large Square</small></button>
            </div>
        </div>

        <!-- Generate Button -->
        <button class="btn btn-primary" id="generateBtn">üöÄ Generate Image</button>

        <!-- Loading Indicator -->
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Generating your image with Nano Banana...</p>
            <p style="color: #666; font-size: 0.9em; margin-top: 10px;">This may take 10-30 seconds</p>
        </div>

        <!-- Alert Messages -->
        <div class="alert alert-error" id="errorAlert"></div>
        <div class="alert alert-info" id="infoAlert"></div>
        <div class="alert alert-success" id="successAlert"></div>

        <!-- Output Section -->
        <div class="output-section" id="outputSection">
            <h2 style="margin-bottom: 20px; text-align: center;">‚ú® Generated Image</h2>
            <div class="output-image">
                <img id="outputImage" alt="Generated" />
                <div class="output-actions">
                    <a href="#" class="btn btn-success" id="downloadBtn" download="nano-banana-generated.png">‚¨áÔ∏è Download</a>
                    <button class="btn btn-primary" id="regenerateBtn" style="width: auto;">üîÑ Regenerate</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // CONFIGURATION - What you need to set up:
        // ============================================
        // 1. Get a Google AI API Key from:
        //    https://aistudio.google.com/apikey
        // 2. Enter it in the API Key field (it will be saved automatically)
        // 3. Optionally adjust the daily rate limit (default: 100)
        // 4. That's it! You're ready to generate images.
        // ============================================

        // DOM Elements
        const elements = {
            apiKey: document.getElementById('apiKey'),
            toggleApiKey: document.getElementById('toggleApiKey'),
            prompt: document.getElementById('prompt'),
            imageInput: document.getElementById('imageInput'),
            fileUploadArea: document.getElementById('fileUploadArea'),
            filePreview: document.getElementById('filePreview'),
            previewImage: document.getElementById('previewImage'),
            filenameDisplay: document.getElementById('filenameDisplay'),
            dimensionBtns: document.querySelectorAll('.dimension-btn'),
            generateBtn: document.getElementById('generateBtn'),
            regenerateBtn: document.getElementById('regenerateBtn'),
            loading: document.getElementById('loading'),
            errorAlert: document.getElementById('errorAlert'),
            infoAlert: document.getElementById('infoAlert'),
            successAlert: document.getElementById('successAlert'),
            outputSection: document.getElementById('outputSection'),
            outputImage: document.getElementById('outputImage'),
            downloadBtn: document.getElementById('downloadBtn'),
            rateLimitCounter: document.getElementById('rateLimitCounter'),
            progressBar: document.getElementById('progressBar'),
            dailyLimitInput: document.getElementById('dailyLimit'),
            resetLimitBtn: document.getElementById('resetLimitBtn'),
            resetInfo: document.getElementById('resetInfo'),
            promptChips: document.querySelectorAll('.prompt-chip'),
            modelSelect: document.getElementById('modelSelect'),
            customModelContainer: document.getElementById('customModelContainer'),
            customModelInput: document.getElementById('customModelInput')
        };

        // State
        let state = {
            selectedDimensions: { width: 1024, height: 1024 },
            uploadedImageBase64: null,
            uploadedImageMimeType: null,
            apiKeyVisible: false,
            selectedModel: 'gemini-2.5-flash-image'
        };

        // ============================================
        // Rate Limit Manager
        // ============================================
        class RateLimitManager {
            constructor() {
                this.storageKey = 'nanoBananaRateLimit';
                this.limitKey = 'nanoBananaDailyLimit';
                this.init();
            }

            init() {
                const data = this.getData();
                const today = this.getTodayDate();

                if (data.date !== today) {
                    this.reset();
                }

                this.scheduleNextReset();
                this.updateUI();
            }

            getTodayDate() {
                return new Date().toDateString();
            }

            getData() {
                const stored = localStorage.getItem(this.storageKey);
                if (stored) {
                    return JSON.parse(stored);
                }
                return { count: 0, date: this.getTodayDate() };
            }

            getLimit() {
                const stored = localStorage.getItem(this.limitKey);
                return stored ? parseInt(stored) : 100;
            }

            setLimit(limit) {
                localStorage.setItem(this.limitKey, limit.toString());
                this.updateUI();
            }

            saveData(data) {
                localStorage.setItem(this.storageKey, JSON.stringify(data));
            }

            increment() {
                const data = this.getData();
                data.count += 1;
                this.saveData(data);
                this.updateUI();
            }

            reset() {
                const data = { count: 0, date: this.getTodayDate() };
                this.saveData(data);
                this.updateUI();
            }

            canGenerate() {
                const data = this.getData();
                const limit = this.getLimit();
                return data.count < limit;
            }

            getRemaining() {
                const data = this.getData();
                const limit = this.getLimit();
                return Math.max(0, limit - data.count);
            }

            updateUI() {
                const data = this.getData();
                const limit = this.getLimit();
                const percentage = (data.count / limit) * 100;

                elements.rateLimitCounter.textContent = `${data.count} / ${limit}`;
                elements.progressBar.style.width = `${Math.min(percentage, 100)}%`;
                elements.progressBar.textContent = percentage > 5 ? `${Math.round(percentage)}%` : '';

                if (percentage >= 80) {
                    elements.rateLimitCounter.classList.add('warning');
                } else {
                    elements.rateLimitCounter.classList.remove('warning');
                }

                this.updateResetInfo();
            }

            updateResetInfo() {
                const now = new Date();
                const tomorrow = new Date(now);
                tomorrow.setDate(tomorrow.getDate() + 1);
                tomorrow.setHours(0, 0, 0, 0);

                const msUntilReset = tomorrow - now;
                const hoursUntilReset = Math.floor(msUntilReset / (1000 * 60 * 60));
                const minutesUntilReset = Math.floor((msUntilReset / (1000 * 60)) % 60);

                elements.resetInfo.textContent = `Resets in ${hoursUntilReset}h ${minutesUntilReset}m`;
            }

            scheduleNextReset() {
                const now = new Date();
                const tomorrow = new Date(now);
                tomorrow.setDate(tomorrow.getDate() + 1);
                tomorrow.setHours(0, 0, 0, 0);

                const msUntilMidnight = tomorrow - now;

                setTimeout(() => {
                    this.reset();
                    this.scheduleNextReset();
                }, msUntilMidnight);

                setInterval(() => this.updateResetInfo(), 60000);
            }
        }

        // ============================================
        // Alert Manager
        // ============================================
        class AlertManager {
            show(message, type = 'error', duration = 5000) {
                // Hide all alerts first
                elements.errorAlert.classList.remove('active');
                elements.infoAlert.classList.remove('active');
                elements.successAlert.classList.remove('active');

                let alertElement;
                switch(type) {
                    case 'error':
                        alertElement = elements.errorAlert;
                        break;
                    case 'info':
                        alertElement = elements.infoAlert;
                        break;
                    case 'success':
                        alertElement = elements.successAlert;
                        break;
                }

                // Handle multi-line messages (convert \n to <br>)
                if (message.includes('\n')) {
                    alertElement.innerHTML = message.split('\n').map(line => {
                        // Make URLs clickable
                        if (line.match(/https?:\/\/[^\s]+/)) {
                            return line.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer" style="color: inherit; text-decoration: underline;">$1</a>');
                        }
                        return line;
                    }).join('<br>');
                } else {
                    // Single line - check for URLs
                    if (message.match(/https?:\/\/[^\s]+/)) {
                        alertElement.innerHTML = message.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer" style="color: inherit; text-decoration: underline;">$1</a>');
                    } else {
                        alertElement.textContent = message;
                    }
                }
                
                alertElement.classList.add('active');

                // Longer duration for quota errors
                if (type === 'error' && message.includes('Quota')) {
                    duration = 15000; // 15 seconds for quota errors
                }

                if (duration > 0) {
                    setTimeout(() => {
                        alertElement.classList.remove('active');
                    }, duration);
                }
            }

            hide() {
                elements.errorAlert.classList.remove('active');
                elements.infoAlert.classList.remove('active');
                elements.successAlert.classList.remove('active');
            }
        }

        // Initialize managers
        const rateLimitManager = new RateLimitManager();
        const alertManager = new AlertManager();

        // ============================================
        // API Key Management
        // ============================================
        const savedApiKey = localStorage.getItem('nanoBananaApiKey');
        if (savedApiKey) {
            elements.apiKey.value = savedApiKey;
        }

        elements.apiKey.addEventListener('input', () => {
            localStorage.setItem('nanoBananaApiKey', elements.apiKey.value);
        });

        elements.toggleApiKey.addEventListener('click', () => {
            state.apiKeyVisible = !state.apiKeyVisible;
            elements.apiKey.type = state.apiKeyVisible ? 'text' : 'password';
            elements.toggleApiKey.textContent = state.apiKeyVisible ? 'üôà' : 'üëÅÔ∏è';
        });

        // ============================================
        // Model Selection Management
        // ============================================
        const savedModel = localStorage.getItem('nanoBananaSelectedModel');
        if (savedModel) {
            elements.modelSelect.value = savedModel;
            state.selectedModel = savedModel;
        } else {
            state.selectedModel = elements.modelSelect.value;
        }

        elements.modelSelect.addEventListener('change', () => {
            const selectedValue = elements.modelSelect.value;
            
            // Show/hide custom model input
            if (selectedValue === 'custom') {
                elements.customModelContainer.style.display = 'block';
                const savedCustomModel = localStorage.getItem('nanoBananaCustomModel');
                if (savedCustomModel) {
                    elements.customModelInput.value = savedCustomModel;
                    state.selectedModel = savedCustomModel;
                } else {
                    state.selectedModel = '';
                }
            } else {
                elements.customModelContainer.style.display = 'none';
                state.selectedModel = selectedValue;
                localStorage.setItem('nanoBananaSelectedModel', state.selectedModel);
            }
        });

        // Handle custom model input changes
        elements.customModelInput.addEventListener('input', () => {
            const customModel = elements.customModelInput.value.trim();
            if (customModel) {
                state.selectedModel = customModel;
                localStorage.setItem('nanoBananaCustomModel', customModel);
            }
        });

        // Initialize custom model container visibility
        if (elements.modelSelect.value === 'custom') {
            elements.customModelContainer.style.display = 'block';
            const savedCustomModel = localStorage.getItem('nanoBananaCustomModel');
            if (savedCustomModel) {
                elements.customModelInput.value = savedCustomModel;
                state.selectedModel = savedCustomModel;
            }
        }

        // ============================================
        // Daily Limit Management
        // ============================================
        elements.dailyLimitInput.value = rateLimitManager.getLimit();

        elements.dailyLimitInput.addEventListener('change', () => {
            const newLimit = parseInt(elements.dailyLimitInput.value);
            if (newLimit > 0 && newLimit <= 10000) {
                rateLimitManager.setLimit(newLimit);
            }
        });

        elements.resetLimitBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to reset the daily counter?')) {
                rateLimitManager.reset();
                alertManager.show('Daily counter reset successfully!', 'success');
            }
        });

        // ============================================
        // Dimension Selection
        // ============================================
        elements.dimensionBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                elements.dimensionBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state.selectedDimensions = {
                    width: parseInt(btn.dataset.width),
                    height: parseInt(btn.dataset.height)
                };
            });
        });

        // ============================================
        // Prompt Suggestions
        // ============================================
        elements.promptChips.forEach(chip => {
            chip.addEventListener('click', () => {
                elements.prompt.value = chip.dataset.prompt;
                elements.prompt.focus();
            });
        });

        // ============================================
        // File Upload with Drag & Drop
        // ============================================
        elements.fileUploadArea.addEventListener('click', () => {
            elements.imageInput.click();
        });

        elements.fileUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.fileUploadArea.classList.add('dragover');
        });

        elements.fileUploadArea.addEventListener('dragleave', () => {
            elements.fileUploadArea.classList.remove('dragover');
        });

        elements.fileUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.fileUploadArea.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type.startsWith('image/')) {
                handleFileUpload(files[0]);
            }
        });

        elements.imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFileUpload(file);
            }
        });

        function handleFileUpload(file) {
            if (file.size > 10 * 1024 * 1024) {
                alertManager.show('File size must be less than 10MB', 'error');
                return;
            }

            elements.filenameDisplay.textContent = `‚úì ${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const dataUrl = e.target.result;
                elements.previewImage.src = dataUrl;
                elements.filePreview.style.display = 'block';
                
                // Extract base64 and mime type
                const matches = dataUrl.match(/^data:(.+);base64,(.+)$/);
                if (matches) {
                    state.uploadedImageMimeType = matches[1];
                    state.uploadedImageBase64 = matches[2];
                }
            };
            reader.readAsDataURL(file);
        }

        // ============================================
        // Image Generation
        // ============================================
        elements.generateBtn.addEventListener('click', handleGenerate);
        elements.regenerateBtn.addEventListener('click', handleGenerate);

        async function handleGenerate() {
            const apiKey = elements.apiKey.value.trim();
            const prompt = elements.prompt.value.trim();

            // Validation
            if (!apiKey) {
                alertManager.show('Please enter your Google AI API key', 'error');
                elements.apiKey.focus();
                return;
            }

            if (!prompt) {
                alertManager.show('Please enter a text prompt', 'error');
                elements.prompt.focus();
                return;
            }

            // Check rate limit
            if (!rateLimitManager.canGenerate()) {
                alertManager.show(`Daily limit reached! You've used all ${rateLimitManager.getLimit()} generations today.`, 'error');
                return;
            }

            // Hide previous results
            elements.outputSection.classList.remove('active');
            alertManager.hide();

            // Show loading
            elements.generateBtn.disabled = true;
            elements.regenerateBtn.disabled = true;
            elements.loading.classList.add('active');

            try {
                const response = await generateImage(
                    apiKey,
                    prompt,
                    state.uploadedImageBase64,
                    state.uploadedImageMimeType,
                    state.selectedDimensions
                );

                if (response.error) {
                    throw new Error(response.error);
                }

                // Increment rate limit
                rateLimitManager.increment();

                // Display image
                const imageData = response.imageBase64;
                elements.outputImage.src = `data:image/png;base64,${imageData}`;
                elements.downloadBtn.href = `data:image/png;base64,${imageData}`;
                elements.outputSection.classList.add('active');

                // Scroll to output
                elements.outputSection.scrollIntoView({ behavior: 'smooth', block: 'start' });

                // Show success message
                const remaining = rateLimitManager.getRemaining();
                if (remaining <= 10) {
                    alertManager.show(`Success! ${remaining} generations remaining today.`, 'info');
                } else {
                    alertManager.show('Image generated successfully!', 'success', 3000);
                }

            } catch (error) {
                console.error('Generation error:', error);
                
                // Format error message
                let errorMessage = error.message;
                
                // Add retry countdown if available
                if (error.retryAfter) {
                    const retrySeconds = Math.ceil(error.retryAfter);
                    errorMessage += `\n\n‚è∞ Auto-retry available in ${retrySeconds} seconds`;
                    
                    // Optionally auto-retry after the delay (commented out to let user decide)
                    // setTimeout(() => {
                    //     if (confirm('Retry now?')) {
                    //         handleGenerate();
                    //     }
                    // }, retrySeconds * 1000);
                }
                
                alertManager.show(errorMessage, 'error');
            } finally {
                elements.generateBtn.disabled = false;
                elements.regenerateBtn.disabled = false;
                elements.loading.classList.remove('active');
            }
        }

        async function generateImage(apiKey, prompt, imageBase64, imageMimeType, dimensions) {
            // Use the selected model from the UI
            let modelName = state.selectedModel || 'gemini-2.5-flash-image';
            
            // If custom model is selected but empty, use default
            if (elements.modelSelect.value === 'custom' && (!modelName || modelName.trim() === '')) {
                throw new Error('Please enter a custom model name or select a different model from the dropdown.');
            }
            
            // Ensure we have a valid model name
            if (!modelName || modelName === 'custom') {
                modelName = 'gemini-2.5-flash-image';
            }
            
            console.log(`Using selected model: ${modelName}`);
            
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent`;
            return await tryGenerateWithModel(url, apiKey, prompt, imageBase64, imageMimeType, dimensions);
        }

        async function tryGenerateWithModel(url, apiKey, prompt, imageBase64, imageMimeType, dimensions) {
            
            const contents = [{
                role: "user",
                parts: [{ text: prompt }]
            }];

            // Add image if provided
            if (imageBase64) {
                contents[0].parts.push({
                    inline_data: {
                        mime_type: imageMimeType || "image/png",
                        data: imageBase64
                    }
                });
            }

            // Add dimension instructions
            const dimensionPrompt = `\n\nOutput dimensions: ${dimensions.width}x${dimensions.height}`;
            contents[0].parts[0].text += dimensionPrompt;

            const requestBody = {
                contents: contents,
                generationConfig: {
                    temperature: 1,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 8192,
                }
            };

            const response = await fetch(`${url}?key=${apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                let errorMessage = errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`;
                let retryAfter = null;
                
                // Handle quota/rate limit errors (429)
                if (response.status === 429) {
                    retryAfter = errorData.error?.details?.[0]?.retryDelay || 
                                errorData.error?.retryDelay ||
                                (errorMessage.match(/Please retry in ([\d.]+)s/) ? 
                                 parseFloat(errorMessage.match(/Please retry in ([\d.]+)s/)[1]) : null);
                    
                    if (errorMessage.includes('quota') || errorMessage.includes('Quota exceeded')) {
                        errorMessage = `‚ùå Quota Exceeded\n\n` +
                            `You've reached your API quota limit. This usually means:\n\n` +
                            `‚Ä¢ Free tier quota has been used up\n` +
                            `‚Ä¢ Billing may need to be enabled in Google Cloud Console\n` +
                            `‚Ä¢ You may need to upgrade your plan\n\n` +
                            `Check your usage: https://ai.dev/usage?tab=rate-limit\n` +
                            `Rate limit info: https://ai.google.dev/gemini-api/docs/rate-limits\n\n` +
                            (retryAfter ? `‚è∞ Retry available in ${Math.ceil(retryAfter)} seconds` : '');
                    } else {
                        errorMessage = `‚è±Ô∏è Rate Limit Reached\n\n` +
                            `Too many requests. ` +
                            (retryAfter ? `Please wait ${Math.ceil(retryAfter)} seconds and try again.` : 
                             'Please wait a moment and try again.');
                    }
                } else if (response.status === 404) {
                    errorMessage = `Model not found (404). This model may not be available with your API key or may have been deprecated.`;
                }
                
                // Create a more user-friendly error object
                const error = new Error(errorMessage);
                error.status = response.status;
                error.retryAfter = retryAfter;
                error.isQuotaError = response.status === 429 && errorMessage.includes('quota');
                throw error;
            }

            const data = await response.json();

            // Debug: Log response structure (only in console)
            console.log('API Response:', JSON.stringify(data, null, 2));

            // Check for finishReason (safety filters, etc.)
            if (data.candidates && data.candidates.length > 0) {
                const candidate = data.candidates[0];
                
                // Check for safety filter or other blocking reasons
                if (candidate.finishReason) {
                    if (candidate.finishReason === 'IMAGE_SAFETY') {
                        const safetyMessage = candidate.finishMessage || 
                            'The image was filtered out because it violated Google\'s Generative AI Prohibited Use policy.';
                        throw new Error(`üõ°Ô∏è Content Safety Filter\n\n${safetyMessage}\n\nTry rephrasing your prompt to avoid prohibited content.`);
                    } else if (candidate.finishReason === 'IMAGE_OTHER') {
                        const otherMessage = candidate.finishMessage || 
                            'The model could not generate the image based on the prompt provided.';
                        throw new Error(`‚ö†Ô∏è Image Generation Failed\n\n${otherMessage}\n\nTry rephrasing your prompt or using different parameters.`);
                    } else if (candidate.finishReason === 'SAFETY' || candidate.finishReason === 'RECITATION') {
                        const reasonMessage = candidate.finishMessage || 
                            `Generation stopped due to: ${candidate.finishReason}`;
                        throw new Error(`‚ö†Ô∏è Content Filtered\n\n${reasonMessage}\n\nPlease try a different prompt.`);
                    } else if (candidate.finishReason !== 'STOP' && candidate.finishReason !== 'MAX_TOKENS') {
                        const reasonMessage = candidate.finishMessage || '';
                        throw new Error(`‚ö†Ô∏è Generation Stopped\n\nReason: ${candidate.finishReason}\n${reasonMessage ? reasonMessage + '\n' : ''}\nPlease try a different prompt.`);
                    }
                }
            }

            // Extract image from response - handle different response formats
            let imageBase64Response = null;
            let responseText = null;

            // Check for candidates array format
            if (data.candidates && data.candidates.length > 0) {
                const candidate = data.candidates[0];
                
                // Check for content.parts format
                if (candidate.content && candidate.content.parts) {
                    const parts = candidate.content.parts;
                    
                    for (const part of parts) {
                        // Handle both camelCase (inlineData) and snake_case (inline_data)
                        if (part.inlineData && part.inlineData.data) {
                            imageBase64Response = part.inlineData.data;
                            break;
                        }
                        if (part.inline_data && part.inline_data.data) {
                            imageBase64Response = part.inline_data.data;
                            break;
                        }
                        if (part.text) {
                            responseText = part.text;
                        }
                    }
                }
                // Check for direct parts array
                else if (candidate.parts) {
                    for (const part of candidate.parts) {
                        // Handle both camelCase (inlineData) and snake_case (inline_data)
                        if (part.inlineData && part.inlineData.data) {
                            imageBase64Response = part.inlineData.data;
                            break;
                        }
                        if (part.inline_data && part.inline_data.data) {
                            imageBase64Response = part.inline_data.data;
                            break;
                        }
                        if (part.text) {
                            responseText = part.text;
                        }
                    }
                }
            }
            // Check for direct parts array in response
            else if (data.parts) {
                for (const part of data.parts) {
                    // Handle both camelCase (inlineData) and snake_case (inline_data)
                    if (part.inlineData && part.inlineData.data) {
                        imageBase64Response = part.inlineData.data;
                        break;
                    }
                    if (part.inline_data && part.inline_data.data) {
                        imageBase64Response = part.inline_data.data;
                        break;
                    }
                    if (part.text) {
                        responseText = part.text;
                    }
                }
            }
            // Check for error in response
            else if (data.error) {
                throw new Error(data.error.message || 'API returned an error');
            }
            // Unknown format
            else {
                console.error('Unexpected response format:', data);
                throw new Error(`Invalid response format from API. Response structure: ${JSON.stringify(Object.keys(data)).substring(0, 200)}`);
            }

            // If we got text instead of image
            if (!imageBase64Response && responseText) {
                throw new Error(`API returned text instead of an image:\n\n${responseText.substring(0, 500)}`);
            }

            // If no image data found
            if (!imageBase64Response) {
                throw new Error('No image data in response. The API may not support image generation with your current plan, or the model may have returned an error. Check the browser console for details.');
            }

            return { imageBase64: imageBase64Response };
        }
    </script>
</body>
</html>

