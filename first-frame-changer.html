<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üçå First Frame Changer - Video Style Transfer</title>
    <style>
        :root {
            --primary: #667eea;
            --primary-dark: #5568d3;
            --secondary: #764ba2;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --info: #17a2b8;
            --bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --shadow: 0 20px 60px rgba(0,0,0,0.3);
            --shadow-hover: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: var(--bg-gradient);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: var(--shadow);
            padding: 40px;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .home-btn {
            display: inline-block;
            margin-bottom: 20px;
            padding: 8px 16px;
            background: var(--primary);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: transform 0.2s ease;
        }

        .home-btn:hover {
            transform: translateY(-2px);
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 700;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            border: 1px solid #e9ecef;
        }

        .section-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        input[type="text"],
        input[type="password"],
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            font-family: inherit;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--primary);
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        .file-upload-area {
            border: 3px dashed #ddd;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .file-upload-area:hover {
            border-color: var(--primary);
            background: #f8f9ff;
        }

        .file-upload-area.dragover {
            border-color: var(--primary);
            background: #e7f3ff;
        }

        .file-upload-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .file-upload-area input[type="file"] {
            display: none;
        }

        .file-preview {
            margin-top: 15px;
            display: none;
        }

        .file-preview img {
            max-width: 100%;
            max-height: 400px;
            border-radius: 8px;
            border: 2px solid #ddd;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .filename-display {
            margin-top: 10px;
            color: var(--success);
            font-weight: 600;
            font-size: 0.9em;
        }

        .image-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .image-grid {
                grid-template-columns: 1fr;
            }
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }

        .option-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option-checkbox:hover {
            border-color: var(--primary);
            background: #f8f9ff;
        }

        .option-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--primary);
        }

        .option-checkbox.checked {
            border-color: var(--primary);
            background: #e7f3ff;
        }

        .btn {
            background: var(--bg-gradient);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            display: inline-block;
            width: 100%;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-hover);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .dimension-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .output-section {
            display: none;
            margin-top: 30px;
        }

        .output-section.active {
            display: block;
        }

        .output-image {
            width: 100%;
            max-width: 800px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin: 20px auto;
            display: block;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .alert.show {
            display: block;
        }

        .alert.error {
            background: #fee;
            border: 1px solid #fcc;
            color: #c33;
        }

        .alert.success {
            background: #efe;
            border: 1px solid #cfc;
            color: #3c3;
        }

        video {
            max-width: 100%;
            max-height: 400px;
            border-radius: 8px;
            border: 2px solid #ddd;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="/" class="home-btn">‚Üê Home</a>
        
        <header>
            <h1>üçå First Frame Changer</h1>
            <p class="subtitle">Transform video first frames with style reference images</p>
        </header>

        <div class="alert" id="alert"></div>

        <div class="section">
            <div class="section-title">‚öôÔ∏è Settings</div>
            
            <div class="form-group">
                <label>Gemini API Key *</label>
                <input type="password" id="apiKey" placeholder="Enter your Gemini API key" />
            </div>

            <div class="form-group">
                <label>Model</label>
                <select id="modelSelect">
                    <option value="gemini-2.5-flash-image">Gemini 2.5 Flash Image</option>
                    <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                    <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                </select>
            </div>

            <div class="form-group dimension-group">
                <div>
                    <label>Width</label>
                    <input type="number" id="width" value="1024" min="256" max="2048" step="64" />
                </div>
                <div>
                    <label>Height</label>
                    <input type="number" id="height" value="1024" min="256" max="2048" step="64" />
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">üìπ First Frame (Video or Image)</div>
            <div class="form-group">
                <label>Upload video file or first frame image</label>
                <div class="file-upload-area" id="firstFrameUploadArea">
                    <div class="file-upload-icon">üé¨</div>
                    <p><strong>Click to upload</strong> or drag and drop</p>
                    <p style="color: #666; font-size: 0.9em; margin-top: 5px;">Video (MP4, MOV, WebM) or Image (JPG, PNG, WebP)</p>
                    <input type="file" id="firstFrameInput" accept="video/*,image/*" />
                </div>
                <div class="filename-display" id="firstFrameFilename"></div>
                <div class="file-preview" id="firstFramePreview">
                    <img id="firstFrameImage" alt="First Frame Preview" />
                    <video id="firstFrameVideo" controls style="display: none;"></video>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">üé® Style Reference Image</div>
            <div class="form-group">
                <label>Upload style reference image</label>
                <div class="file-upload-area" id="styleUploadArea">
                    <div class="file-upload-icon">üñºÔ∏è</div>
                    <p><strong>Click to upload</strong> or drag and drop</p>
                    <p style="color: #666; font-size: 0.9em; margin-top: 5px;">JPG, PNG, WebP (Max 10MB)</p>
                    <input type="file" id="styleInput" accept="image/*" />
                </div>
                <div class="filename-display" id="styleFilename"></div>
                <div class="file-preview" id="stylePreview">
                    <img id="styleImage" alt="Style Preview" />
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">‚öôÔ∏è Keep From First Frame</div>
            <div class="form-group">
                <label>Select what to preserve from the first frame (everything else will be transformed from style reference):</label>
                <div class="options-grid">
                    <label class="option-checkbox" id="keepPoseLabel">
                        <input type="checkbox" id="keepPose" checked />
                        <span>ü§∏ Pose & Position</span>
                    </label>
                    <label class="option-checkbox" id="keepCharacterLabel">
                        <input type="checkbox" id="keepCharacter" />
                        <span>üë§ Character</span>
                    </label>
                    <label class="option-checkbox" id="keepOutfitLabel">
                        <input type="checkbox" id="keepOutfit" />
                        <span>üëî Outfit</span>
                    </label>
                    <label class="option-checkbox" id="keepSettingLabel">
                        <input type="checkbox" id="keepSetting" />
                        <span>üè† Setting</span>
                    </label>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">‚úçÔ∏è Prompt Guidance (Optional)</div>
            <div class="form-group">
                <label>Additional instructions for the transformation</label>
                <textarea id="promptGuidance" placeholder="e.g., Make it more cinematic, add dramatic lighting, change to winter setting, etc."></textarea>
            </div>
        </div>

        <button class="btn" id="generateBtn">üöÄ Generate First Frame</button>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Generating your transformed first frame...</p>
        </div>

        <div class="output-section" id="outputSection">
            <div class="section">
                <div class="section-title">‚ú® Generated First Frame</div>
                <img id="outputImage" class="output-image" alt="Generated First Frame" />
                <div style="text-align: center; margin-top: 20px;">
                    <a id="downloadBtn" class="btn" download="first-frame.png" style="max-width: 300px; text-decoration: none; display: inline-block;">
                        üíæ Download First Frame
                    </a>
                </div>
            </div>
        </div>
    </div>

    <script>
        const state = {
            firstFrameBase64: null,
            firstFrameMimeType: null,
            styleBase64: null,
            styleMimeType: null,
            isVideo: false
        };

        const elements = {
            apiKey: document.getElementById('apiKey'),
            modelSelect: document.getElementById('modelSelect'),
            width: document.getElementById('width'),
            height: document.getElementById('height'),
            firstFrameInput: document.getElementById('firstFrameInput'),
            firstFrameUploadArea: document.getElementById('firstFrameUploadArea'),
            firstFrameFilename: document.getElementById('firstFrameFilename'),
            firstFramePreview: document.getElementById('firstFramePreview'),
            firstFrameImage: document.getElementById('firstFrameImage'),
            firstFrameVideo: document.getElementById('firstFrameVideo'),
            styleInput: document.getElementById('styleInput'),
            styleUploadArea: document.getElementById('styleUploadArea'),
            styleFilename: document.getElementById('styleFilename'),
            stylePreview: document.getElementById('stylePreview'),
            styleImage: document.getElementById('styleImage'),
            keepPose: document.getElementById('keepPose'),
            keepCharacter: document.getElementById('keepCharacter'),
            keepOutfit: document.getElementById('keepOutfit'),
            keepSetting: document.getElementById('keepSetting'),
            keepPoseLabel: document.getElementById('keepPoseLabel'),
            keepCharacterLabel: document.getElementById('keepCharacterLabel'),
            keepOutfitLabel: document.getElementById('keepOutfitLabel'),
            keepSettingLabel: document.getElementById('keepSettingLabel'),
            promptGuidance: document.getElementById('promptGuidance'),
            generateBtn: document.getElementById('generateBtn'),
            loading: document.getElementById('loading'),
            outputSection: document.getElementById('outputSection'),
            outputImage: document.getElementById('outputImage'),
            downloadBtn: document.getElementById('downloadBtn'),
            alert: document.getElementById('alert')
        };

        // Load saved API key
        const savedKey = localStorage.getItem('first-frame-changer-api-key');
        if (savedKey) {
            elements.apiKey.value = savedKey;
        }

        elements.apiKey.addEventListener('input', () => {
            localStorage.setItem('first-frame-changer-api-key', elements.apiKey.value);
        });

        // Update checkbox labels
        [elements.keepPose, elements.keepCharacter, elements.keepOutfit, elements.keepSetting].forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                const label = checkbox.closest('label');
                if (checkbox.checked) {
                    label.classList.add('checked');
                } else {
                    label.classList.remove('checked');
                }
            });
        });

        // Initialize checkbox states
        elements.keepPoseLabel.classList.add('checked');

        // First frame upload handlers
        elements.firstFrameUploadArea.addEventListener('click', () => {
            elements.firstFrameInput.click();
        });

        elements.firstFrameUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.firstFrameUploadArea.classList.add('dragover');
        });

        elements.firstFrameUploadArea.addEventListener('dragleave', () => {
            elements.firstFrameUploadArea.classList.remove('dragover');
        });

        elements.firstFrameUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.firstFrameUploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) {
                handleFirstFrameUpload(file);
            }
        });

        elements.firstFrameInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFirstFrameUpload(file);
            }
        });

        function handleFirstFrameUpload(file) {
            if (file.type.startsWith('video/')) {
                // Handle video - extract first frame
                state.isVideo = true;
                const video = document.createElement('video');
                const url = URL.createObjectURL(file);
                video.src = url;
                video.onloadedmetadata = () => {
                    video.currentTime = 0.1; // Get frame at 0.1 seconds
                };
                video.onseeked = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0);
                    
                    canvas.toBlob((blob) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const dataUrl = e.target.result;
                            const matches = dataUrl.match(/^data:(.+);base64,(.+)$/);
                            if (matches) {
                                state.firstFrameMimeType = matches[1];
                                state.firstFrameBase64 = matches[2];
                            }
                            elements.firstFrameImage.src = dataUrl;
                            elements.firstFrameImage.style.display = 'block';
                            elements.firstFrameVideo.style.display = 'none';
                            elements.firstFramePreview.style.display = 'block';
                            elements.firstFrameFilename.textContent = `‚úì ${file.name} (first frame extracted)`;
                        };
                        reader.readAsDataURL(blob);
                    }, 'image/png');
                    URL.revokeObjectURL(url);
                };
            } else if (file.type.startsWith('image/')) {
                // Handle image
                state.isVideo = false;
                if (file.size > 10 * 1024 * 1024) {
                    showAlert('File size must be less than 10MB', 'error');
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    elements.firstFrameImage.src = dataUrl;
                    elements.firstFrameImage.style.display = 'block';
                    elements.firstFrameVideo.style.display = 'none';
                    elements.firstFramePreview.style.display = 'block';
                    elements.firstFrameFilename.textContent = `‚úì ${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
                    
                    const matches = dataUrl.match(/^data:(.+);base64,(.+)$/);
                    if (matches) {
                        state.firstFrameMimeType = matches[1];
                        state.firstFrameBase64 = matches[2];
                    }
                };
                reader.readAsDataURL(file);
            }
        }

        // Style image upload handlers
        elements.styleUploadArea.addEventListener('click', () => {
            elements.styleInput.click();
        });

        elements.styleUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.styleUploadArea.classList.add('dragover');
        });

        elements.styleUploadArea.addEventListener('dragleave', () => {
            elements.styleUploadArea.classList.remove('dragover');
        });

        elements.styleUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.styleUploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                handleStyleUpload(file);
            }
        });

        elements.styleInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleStyleUpload(file);
            }
        });

        function handleStyleUpload(file) {
            if (file.size > 10 * 1024 * 1024) {
                showAlert('File size must be less than 10MB', 'error');
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                const dataUrl = e.target.result;
                elements.styleImage.src = dataUrl;
                elements.stylePreview.style.display = 'block';
                elements.styleFilename.textContent = `‚úì ${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
                
                const matches = dataUrl.match(/^data:(.+);base64,(.+)$/);
                if (matches) {
                    state.styleMimeType = matches[1];
                    state.styleBase64 = matches[2];
                }
            };
            reader.readAsDataURL(file);
        }

        function showAlert(message, type) {
            elements.alert.textContent = message;
            elements.alert.className = `alert ${type} show`;
            setTimeout(() => {
                elements.alert.classList.remove('show');
            }, 5000);
        }

        // Generate ultra-realistic skin, lighting, and camera realism enhancement
        function getRealisticEnhancement() {
            return `

ULTRA-REALISTIC SKIN & LIGHTING REQUIREMENTS (CRITICAL):

SKIN REALISM (FOCUS):
- Visible pores and fine micro-texture throughout the skin
- Natural acne marks, blemishes, and imperfections with organic variation (not patterned or symmetrical)
- Uneven pigmentation and subtle redness in natural areas (cheeks, nose, around mouth)
- Natural oil sheen ONLY on high points (cheekbones, nose bridge, forehead), matte elsewhere
- NO symmetry correction - natural facial asymmetry preserved
- Skin must look healthy and alive, not dull, not glossy
- Luminous quality must come from real light only, not digital effects
- NO retouching, NO smoothing, NO beauty filters
- Natural imperfections must be preserved (freckles, moles, fine lines, texture variations)

COLOR & LIGHT (IMPORTANT):
- Real daylight with slight warmth, NOT neutral grey or cool tones
- Natural contrast (NOT flat, NOT cinematic, NOT over-dramatic)
- Accurate white balance - colors must be true-to-life
- True-to-life colors: skin tones rich and dimensional, fabrics clearly defined, objects have natural color depth
- NO faded colors, NO dusty tones, NO pastel palette, NO washed-out aesthetic
- Colors must be vibrant but natural, not oversaturated

CAMERA BEHAVIOR:
- Phone-camera realism: slight edge softness, natural focus falloff
- Subtle sensor grain appropriate to the lighting conditions
- Natural depth of field where appropriate
- No artificial sharpening or over-processing

OVERALL AESTHETIC:
- Modern, clean, minimal, intimate, non-commercial feel
- Editorial-documentary aesthetic
- Must feel like a real person, real skin, real moment
- Authentic and unposed quality

STRICT NEGATIVES (AVOID):
- Faded colors, pastel tones, beige aesthetic
- Flat lighting, overexposed whites, harsh shadows
- AI glow, plastic skin, skincare-ad look
- Studio lighting, artificial lighting setups
- Cartoon style, 3D render style, illustration style
- Text, logos, watermarks
- Over-smoothing, airbrushing, digital retouching effects
- Unnatural symmetry, perfect skin, flawless appearance`;
        }

        elements.generateBtn.addEventListener('click', async () => {
            if (!elements.apiKey.value.trim()) {
                showAlert('Please enter your Gemini API key', 'error');
                return;
            }

            if (!state.firstFrameBase64) {
                showAlert('Please upload a video or first frame image', 'error');
                return;
            }

            if (!state.styleBase64) {
                showAlert('Please upload a style reference image', 'error');
                return;
            }

            elements.generateBtn.disabled = true;
            elements.loading.classList.add('active');
            elements.outputSection.classList.remove('active');

            try {
                // Build prompt - treat first frame as tracing template
                let prompt = `CRITICAL INSTRUCTIONS - TRACING PAPER METHOD:
                
The first image is your TRACING TEMPLATE. The second image is your CHARACTER/STYLE REFERENCE.

You must treat this like tracing paper:
1. Use the FIRST image as an EXACT template for:
   - Body pose and positioning (every limb, joint, angle must match exactly)
   - Camera angle and perspective (identical viewpoint)
   - Composition and framing (same crop, same positioning in frame)
   - Body proportions and silhouette shape
   - Head position and angle
   - Hand and foot positions
   - Weight distribution and stance
   - Any props or objects being held/interacted with

2. From the SECOND image, extract ONLY:
   - Character appearance (facial features, hair, skin tone)
   - Clothing style and outfit
   - Visual aesthetic and style
   - Color palette and mood

3. The result should look like you traced the exact pose from the first image but drew a completely different character from the second image in that same pose.

CRITICAL: The pose, positioning, camera angle, and composition must be IDENTICAL to the first frame. Only the character appearance, clothing, and style should come from the second image. This is for video generation frame consistency - the pose must match exactly like tracing paper.

Output dimensions: ${parseInt(elements.width.value)}x${parseInt(elements.height.value)}`;

                // Add optional keep/change instructions if user wants to modify behavior
                const keepParts = [];
                if (elements.keepPose.checked) keepParts.push('pose');
                if (elements.keepCharacter.checked) keepParts.push('character');
                if (elements.keepOutfit.checked) keepParts.push('outfit');
                if (elements.keepSetting.checked) keepParts.push('setting');
                
                if (keepParts.length < 4) {
                    prompt += `\n\nNote: User wants to preserve: ${keepParts.length > 0 ? keepParts.join(', ') : 'nothing'}. Adjust accordingly, but ALWAYS maintain exact pose positioning if pose is checked.`;
                }

                const additionalPrompt = elements.promptGuidance.value.trim();
                if (additionalPrompt) {
                    prompt += `\n\nAdditional user instructions: ${additionalPrompt}`;
                }

                // Add ultra-realistic skin and lighting enhancement
                prompt += getRealisticEnhancement();

                const imageUrl = await generateImage(
                    elements.apiKey.value,
                    prompt,
                    state.firstFrameBase64,
                    state.firstFrameMimeType,
                    state.styleBase64,
                    state.styleMimeType,
                    parseInt(elements.width.value),
                    parseInt(elements.height.value)
                );

                elements.outputImage.src = imageUrl;
                elements.downloadBtn.href = imageUrl;
                elements.outputSection.classList.add('active');
                elements.outputSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                showAlert('First frame generated successfully!', 'success');

            } catch (error) {
                console.error('Generation error:', error);
                showAlert(`Error: ${error.message}`, 'error');
            } finally {
                elements.generateBtn.disabled = false;
                elements.loading.classList.remove('active');
            }
        });

        async function generateImage(apiKey, prompt, firstFrameBase64, firstFrameMimeType, styleBase64, styleMimeType, width, height) {
            const model = elements.modelSelect.value;
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;

            // Add ultra-realistic skin and lighting enhancement to prompt
            let enhancedPrompt = prompt + getRealisticEnhancement();

            const contents = [{
                role: "user",
                parts: [
                    { text: `${enhancedPrompt}\n\nOutput dimensions: ${width}x${height}` },
                    {
                        inline_data: {
                            mime_type: firstFrameMimeType || "image/png",
                            data: firstFrameBase64
                        }
                    },
                    {
                        inline_data: {
                            mime_type: styleMimeType || "image/png",
                            data: styleBase64
                        }
                    }
                ]
            }];

            const requestBody = {
                contents: contents,
                generationConfig: {
                    temperature: 1,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 8192,
                }
            };

            const response = await fetch(`${url}?key=${apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();

            // Extract image from response
            const candidate = data.candidates?.[0];
            if (!candidate || !candidate.content || !candidate.content.parts) {
                throw new Error('No image generated in response');
            }

            const part = candidate.content.parts.find(p => p.inlineData || p.inline_data);
            if (!part) {
                throw new Error('No image data found in response');
            }

            // Convert base64 to blob URL
            const base64Data = (part.inlineData || part.inline_data)?.data;
            if (!base64Data) {
                throw new Error('No image data in response part');
            }

            const mimeType = (part.inlineData || part.inline_data)?.mimeType || 'image/png';
            const blob = base64ToBlob(base64Data, mimeType);
            return URL.createObjectURL(blob);
        }

        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        }
    </script>
</body>
</html>

